#+TITLE: Conforguration
#+AUTHOR: William Denton
#+EMAIL: wtd@pobox.com

#+STARTUP: content entitiespretty inlineimages
#+OPTIONS: toc:nil ^:nil

# These variables are hardcoded now.  Could maybe abstract them out later.
# +PROPERTY: header-args :var script_dir="conforguration_scripts" :var dotfiles_dir="dotfiles"

If you're looking at this on GitHub, the BEGIN and END source block wrappers are hidden, so you can't see the parameters.  Look at the raw version of the file, or clone the repository and load it into Emacs, to read it properly.

* Tangle everything

Before anything else, make sure that everything has been tangled, so all the dot files and install scripts are up to date.

There are three ways to do it:

+ Hit the keystroke =C-c C-v t=;
+ Run =M-x org-babel-tangle=;
+ Or hit =C-c C-c= on the following code block:

#+begin_src elisp :results silent
(org-babel-tangle)
#+end_src
They all do the same thing.

* Initialize

This only needs to be done once per machine, to create =/usr/local/src/= and make it owned by oneself.  This is where all source code will be downloaded and compiled.

#+begin_src shell :tangle conforg/scripts/initialize.sh :shebang "#!/bin/bash"
sudo mkdir -p /usr/local/src/
sudo chown $USER:$USER /usr/local/src
#+end_src

* Installing

** Copy the dot files and scripts into place

Everything in the =conforg= directory needs to be copied to $HOME.  The easiest way to do this is with =rsync=, which will create any directories necessary.  To make sure no old cruft accumulates, delete anything in the target directory that shouldn't be there.

#+begin_src shell :tangle install/install.sh :shebang "#!/bin/bash"
rsync --archive --delete ~/src/conforguration/conforg/ ${HOME}/conforg/
#+end_src

#+RESULTS:

** Script to create symlinks for the dot files

Once all the dot files are in =~/conforg/dotfiles/=, we need a script to set them up in the home directory.  This is done by making symlinks.

First, to be safe, move into the directory where the script is run.

#+begin_src shell :tangle conforg/dotfiles/link-dotfiles.sh :shebang "#!/bin/bash" :eval no
cd "$(dirname "$0")"
# echo "PWD is " $(pwd)
#+end_src

The dot files are in two directories:  =mine= and =imported=.  Go into each directory and make a symbolic link (specifying the full path) to =file= from =~/.file=.  In other words, =~/.bashrc= is a symlink to the =mine/bashrc= here.

(To be absolutely safe, all the filenames should be in double quotes, but there are no spaces or strange characters in my filenames, so I'm going to leave that out.)

#+begin_src shell :tangle conforg/dotfiles/link-dotfiles.sh :shebang "#!/bin/bash" :eval no
for dir in mine imported; do
    echo $dir
    cd $dir
    for file in *; do
	echo "  " $file
	rm -f ~/.${file}
	ln -s ~/conforg/dotfiles/${dir}/${file} ~/.${file}
    done
    cd ..
done
#+end_src

Finally, make sure that the =.bash_profile= is the real =.profile=, so no errant leftover =.profile= can get in the way.

#+begin_src shell :tangle conforg/dotfiles/link-dotfiles.sh :shebang "#!/bin/bash" :eval no
rm ~/.profile
ln -s ~/.bash_profile ~/.profile
#+end_src

Once this is run you need to open up a new shell, or =source ~/.bashrc=, to see any changes.

** Install

Add a line to the install script to call the above linking script.  This =install.sh= script can be run when Conforguration is pulled down fresh from GitHub on a new machine, and will put everything in place.  To update and refresh dot files and scripts locally within Emacs, you should use the localhost section below.

#+begin_src shell :tangle install/install.sh
~/conforg/dotfiles/link-dotfiles.sh
#+end_src

** Noweb for installing remotely

TODO:  Explain.

#+NAME: install-conforg-remotely
#+begin_src shell
rsync --archive --compress --delete ~/src/conforguration/conforg/ ${hostname}:conforg/
ssh ${hostname} "conforg/dotfiles/link-dotfiles.sh"
#+end_src

* Dot files

** Introduction

Almost all of my "dot files" ([[https://en.wikipedia.org/wiki/Run_commands][run command files]], containing configuration instructions for different programs) are in this Org file.  Most lines have a comment explaining what they are for, and when I've cribbed something from some web page or another's dot file (which is frequent), I've credited it where possible.

There are two kinds of dot files: "mine" and "imported."  Most are "mine," and are handled completely in this Org file.  The "imported" ones are copied completely from elsewhere, usually some software distribution that has one particular file I need.  Right now there are only three imported files:  one is a script that does completion for Git in bash, one makes ls listings be in colour, and the third, which configures a LaTeX linter, really should be under "mine" but it's so long I can't be bothered right now.

The files that are "mine" are all tangled from this Org file.  The "imported" ones are copied as is.

If you need some special environment variables on a machine, put them in ~.bash.$HOSTNAME.rc~, as described at the bottom of ~.bashrc~.  That's one way of setting up private environment variables that hold passwords or API tokens.

A note about languages specified in the source blocks:  the language setting is required, but it doesn't have to be a known and supported language.  So in order for the =.tmuxrc= to be tangled, for example, I say it has the language "tmux," which doesn't exist but makes it work.

** Abcde

*** Config (=.abcde.conf=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/abcde.conf
:END:

Abcde is [[https://abcde.einval.com/wiki/][A Better CD Encoder]].  With one program I can digitize a CD all in one go, and with luck get some metadata from [[https://musicbrainz.org/][MusicBrainz]].  This configuration I [[https://www.andrews-corner.org/abcde/][lifted from Andrew's Corner]] and left alone.  All I want to do is turn the CD into FLAC files, and with this all I have to do is run =abcde= without any options.  Then I use [[https://wiki.gnome.org/Apps/EasyTAG][EasyTAG]] to clean up the metadata.

LOWDISK "conserves disk space by encoding tracks immediately after reading them" (I quote from the man page) which may not be too big a deal, but:  "Note that this option may also help when reading a CD with errors. This is because on a scratchy disk reading is quite timing sensitive and this option reduces the background load on the system which allows the ripping program more precise control."  That's useful.

#+begin_src abcde
LOWDISK=y
#+end_src

Where to retrieve track information.

#+begin_src abcde
CDDBMETHOD=musicbrainz
#+end_src

Make a local cache of CDDB entries and then volunteer to use these entries when and if they match the CD.

#+begin_src abcde
CDDBCOPYLOCAL="y"
CDDBLOCALDIR="$HOME/.cddb"
CDDBLOCALRECURSIVE="y"
CDDBUSELOCAL="y"
#+end_src

Specify the encoder to use for FLAC. In this case flac is the only choice.

#+begin_src abcde
FLACENCODERSYNTAX=flac
#+end_src

Specify the path to the selected encoder.  It's in my PATH so I don't need to specify a full path.

#+begin_src abcde
FLAC=flac
#+end_src

Specify your required encoding options here. Multiple options can be selected as '--best --another-option' etc. Overall bitrate is about 880 kbs/s with level 8.

#+begin_src abcde
# FLACOPTS='-s -e -V -8'
FLACOPTS='--silent --exhaustive-model-search --verify --compression-level-8'
#+end_src

Output type for FLAC.

#+begin_src abcde
OUTPUTTYPE="flac"
#+end_src

The CD ripping program to use. There are a few choices here: cdda2wav, dagrab, cddafs (Mac OS X only) and flac.

#+begin_src abcde
CDROMREADERSYNTAX=cdparanoia
#+end_src

Specify the location of the ripping program and pass any extra options.

#+begin_src abcde
CDPARANOIA=cdparanoia
CDPARANOIAOPTS="--never-skip=40"
#+end_src

Path to the CD identification program.

#+begin_src abcde
CDDISCID=cd-discid
#+end_src

The base location for the encoded music files.

#+begin_src abcde
OUTPUTDIR="$HOME/Music"
#+end_src

Default actions that abcde will take.

#+begin_src abcde
ACTIONS=cddb,playlist,read,encode,tag,move,clean
#+end_src

Decide here how you want the tracks labelled for a standard 'single-artist', multi-track encode and also for a multi-track, 'various-artist' encode:

#+begin_src abcde
OUTPUTFORMAT='${OUTPUT}/${ARTISTFILE}-${ALBUMFILE}/${TRACKNUM}.${TRACKFILE}'
VAOUTPUTFORMAT='${OUTPUT}/Various-${ALBUMFILE}/${TRACKNUM}.${ARTISTFILE}-${TRACKFILE}'
#+end_src

Decide here how you want the tracks labelled for a standard 'single-artist',  single-track encode and also for a single-track 'various-artist' encode.  (Create a single-track encode with 'abcde -1' from the command line.)

#+begin_src abcde
ONETRACKOUTPUTFORMAT='${OUTPUT}/${ARTISTFILE}-${ALBUMFILE}/${ALBUMFILE}'
VAONETRACKOUTPUTFORMAT='${OUTPUT}/Various-${ALBUMFILE}/${ALBUMFILE}'
#+end_src

Create playlists for single and various-artist encodes.

#+begin_src abcde
PLAYLISTFORMAT='${OUTPUT}/${ARTISTFILE}-${ALBUMFILE}/${ALBUMFILE}.m3u'
VAPLAYLISTFORMAT='${OUTPUT}/Various-${ALBUMFILE}/${ALBUMFILE}.m3u'
#+end_src

The man page says, "mungefilename() is an abcde shell function that can be overridden via abcde.conf. It takes CDDB data as $1 and outputs the resulting filename on stdout."  This one takes out dots preceding the album name, and removes other difficult characters.

#+begin_src abcde
mungefilename ()
{
  echo "$@" | sed -e 's/^\.*//' | tr -d ":><|*/\"'?[:cntrl:]"
}
#+end_src

Use two encoders simultaneously.

#+begin_src abcde
MAXPROCS=2
#+end_src

Number tracks as 01 and 02, not 1 and 2.

#+begin_src abcde
PADTRACKS=y
#+end_src

Make output more verbose.  Most verbose is 2.

#+begin_src abcde
EXTRAVERBOSE=1
#+end_src

Add a comment?  No.

#+begin_src abcde
COMMENT=""
#+end_src

Finally, eject the CD when done.

#+begin_src abcde
EJECTCD=y
#+end_src


** Bash

My shell is [[https://www.gnu.org/software/bash/][Bash]].  I've looked at other ones, and some do fancy impressive things, but my shell needs are fairly simple.

I've forgotten the intricacies of when a =.profile= is used and how interactive and non-interactive shells handle things differently, but what I have works for me.

*** Profile (=.bash_profile=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/bash_profile
:END:

First, I set [[https://www.gnu.org/software/gettext/manual/html_node/Locale-Environment-Variables.html#Locale-Environment-Variables][locale environment variables]] to say I want to use English, specifically Canadian English.

#+begin_src shell
export LANG=en_CA.UTF-8
export LC_ALL=en_CA.UTF-8
#+end_src

If these locales aren't available---perhaps because this is running on a new machine---then I need to run these to configure it.  This is only necessary once.

#+begin_src shell :tangle no
sudo locale-gen en_CA.UTF-8
sudo update-locale LANG=en_CA.UTF-8
#+end_src

Then the =.bashrc= is processed.

#+begin_src shell
source ~/.bashrc
#+end_src

There are some settings or commands (like calling =ssh-add= for a particular host) that I use on a particular machine, and this makes that possible.  If the machine is named =dartagnan=, put commands in =~/.profile.dartagnan= (similar to the =.bashrc=) for them just to be  run in login shells there.

#+begin_src shell
if [ -f ~/.profile."$HOSTNAME" ] ; then
    . ~/.profile.$HOSTNAME
fi
#+end_src

*** Config (=.bashrc=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/bashrc
:END:

**** File permissions

Set the default "user file-created mask" to 022, so that by default regular files are created 644 (=-rw-r--r--=) and executables 755 (=-rwxr-xr-x=)

#+begin_src shell
umask 022
#+end_src

**** Editing

My preferred editor is Emacs (of course) but I define these so that if someone pops up an editor it doesn't use vi.

#+begin_src shell
export EDITOR=nano
export VISUAL=nano
#+end_src

**** Web

The only thing I ever use that pays attention to =WWW_HOME= is lynx, I think, but [[https://duckduckgo.com/][DuckDuckGo]] is a good default first page to load if something is going to try.

#+begin_src shell
export WWW_HOME=https://duckduckgo.com/
#+end_src

**** History

Don't put duplicate lines or lines starting with space in the history.

#+begin_src shell
HISTCONTROL=ignoreboth
#+end_src

The commands listed here will be ignored by history.  If I run =cd= and then hit <up>, =cd= doesn't reappear.

#+begin_src shell
HISTIGNORE="cd:df:pwd:[bf]g:exit:history"
#+end_src

Set the number of commands to remember, and the file size of =.bash_history=.

#+begin_src shell
HISTSIZE=10000
HISTFILESIZE=1000000
#+end_src

Append to the history file, don't overwrite it.

#+begin_src shell
shopt -s histappend
#+end_src

Append and reload the history after each command, so the full history is available in all shells simultaneously.  But watch out!  If I'm being active in different shells at the same time then I need to be careful about which command reappears with <up>.

#+begin_src shell
PROMPT_COMMAND="history -a; history -n"
#+end_src

**** Terminals

Check the terminal window size after each command and, if necessary, update the values of LINES and COLUMNS.

#+begin_src shell
shopt -s checkwinsize
#+end_src

Puts wtd@hostname (or whatever) in the title bar of the terminal window.  For it to change when you login to another machine, it needs to be in your =.bashrc= there too.  Very handy when using tabs.

#+begin_src shell
if [ "$TERM" = 'xterm' ] || [ "$TERM" = 'rxvt' ] || [ "$TERM" = 'xterm-256color' ]
then
    export PROMPT_COMMAND='echo -ne "\033]2;"`whoami`@`hostname -s`"\007"'
fi
#+end_src

**** Solarized theme

Apply a [[https://ethanschoonover.com/solarized/][Solarized]] theme to color ls listings.  Taken from [[https://github.com/seebi/dircolors-solarized][dircolors-solarized]].  I'm using =dircolors.ansi-dark=.

#+begin_src shell
if command -v dircolors > /dev/null 2>&1
then
    eval "$(dircolors ~/.dircolors.ansi-dark)"
fi
#+end_src
# Also use solarized theme in GNOME terminal
# See https://github.com/sigurdga/gnome-terminal-colors-solarized

**** Prompt

The [[https://xta.github.io/HalloweenBash/][Bash Profile Generator]] is very useful here.  For colours, see also [[https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x329.html][the colours section]] from this ancient [[https://tldp.org/HOWTO/Bash-Prompt-HOWTO/][Bash Prompt HOWTO]].

First, set a bunch of colours, some of which I don't use.

#+begin_src shell
RED="\[\033[0;31m\]"
# LIGHT_RED="\[\033[1;31m\]"
# YELLOW="\[\033[1;33m\]"
GREEN="\[\033[0;32m\]"
# LIGHT_GREEN="\[\033[1;32m\]"
# CYAN="\[\033[0;36m\]"
# LIGHT_CYAN="\[\033[1;36m\]"
BLUE="\[\033[0;34m\]"
# LIGHT_BLUE="\[\033[1;34m\]"
PURPLE="\[\033[0;35m\]"
OCHRE="\e[38;2;204;119;34m\]" ## RGB (204, 119, 34), see https://stackoverflow.com/a/26665998

# WHITE='\e[0;37m'
# LIGHT_GRAY="\[\033[0;37m\]"
# GRAY="\[\033[1;30m\]"
# BLACK="\[\033[0;30m\]"

NO_COLOUR="\[\033[0m\]"
#+end_src

I use a blue prompt on my home machine(s), green on my hosted shell server, and red elsewhere.

#+begin_src shell
case $HOSTNAME in
    marcus)
	PROMPT_COLOUR=$BLUE
	;;
    shell3)
	PROMPT_COLOUR=$GREEN
	;;
    ochre)
	PROMPT_COLOUR=$OCHRE
	;;
    ,*)
	PROMPT_COLOUR=$RED
esac
#+end_src

Root is purple.

#+begin_src shell
if [[ ${EUID} == 0 ]] ; then
    PROMPT_COLOUR=$PURPLE
fi
#+end_src

Now I can define the actual prompt.  Note that =\$= is # if root, $ otherwise; it needs to be escaped.

First a prompt I don't use, but it's good to keep as a reference.

#+begin_example
┌─[07:47 PM]─[wtd@marcus:~]
└─> $
#+end_example

#+begin_src shell :tangle no
export PS1="\342\224\214\342\224\200[\@]\342\224\200[\u@\h:\w]\n\342\224\224\342\224\200> \\$ "
#+end_example

Then the prompt I was using until I move this into Org.

#+begin_example
┌─[marcus]─[~/src/conforguration/dotfiles]
└─> $
#+end_example

#+begin_src shell :tangle no
PS1="\342\224\214\342\224\200[\h]\342\224\200[\w]\n\342\224\224\342\224\200> \\$ "
#+end_src

I simplified it a bit and discovered I can use Unicode characters instead of those ugly escape characters!

#+begin_example
┌─[marcus]─[~/src/conforguration/dotfiles]
└─$
#+end_example

#+begin_src shell
PROMPT="┌─[\h]─[\w]\n└─\\$ "
#+end_src

Set the prompt to be the colour I want.

#+begin_src shell
PS1="${PROMPT_COLOUR}${PROMPT}${NO_COLOUR}"
#+end_src

Glue the prompt to always go to the first column ([[https://jonisalonen.com/2012/your-bash-prompt-needs-this/][source]]).

#+begin_src shell
PS1="\[\033[G\]$PS1"
#+end_src

If I'm in a dumb terminal (when does that happen?) then use a very basic prompt.

#+begin_src shell
if [[ "$TERM" == "dumb" ]] ; then
    PS1="$ "
fi
#+end_src

Do I ever see a secondary prompt?  I'm not sure.

#+begin_src shell
PS2="${PROMPT_COLOUR}\342\224\224> ${NO_COLOUR}"
#+end_src

**** Key remapping

I used to need to remap some keys on my Lenovo X240, but whatever the problem was, I figured it out some other way, so this isn't needed.

#+begin_src shell :tangle no
if [ -f ~/.Xmodmap ]; then
    xmodmap ~/.Xmodmap
fi
#+end_src

**** Command aliases

Use colours when grepping.

#+begin_src shell
export GREP_COLORS='mt=1;37;44'
alias grep='grep --color=auto'
#+end_src

Call up LibreOffice with just =o file=.

#+begin_src shell
alias o='libreoffice'
#+end_src

Open up [[https://alpine.x10host.com/][Alpine]] and go right to the inbox.

#+begin_src shell
alias pi='alpine -i'
#+end_src

Be polite.

#+begin_src shell
alias please='sudo'
#+end_src

In case =rm -i= is set system-wide.

#+begin_src shell
alias rm="rm"
#+end_src

Always preserve timestamps when using =scp=.

#+begin_src shell
alias scp="scp -p"
#+end_src

Get the weather with [[https://github.com/chubin/wttr.in][wttr.in]].

#+begin_src shell
alias ww="curl https://wttr.in/yyz"
#+end_src

Open any file in the default application with just =x file=.

#+begin_src shell
alias x='xdg-open'
#+end_src

Don't show snaps in =df= listings.  They use a particular file system, which can be excluded.

#+begin_src shell
alias df='df -x "squashfs"'
#+end_src

**** ls

Count in proper kilobytes.

#+begin_src shell
export BLOCKSIZE=1024
#+end_src

Generally I'm on Linux machines, but if I'm on a FreeBSD box it has a different ls with different options, so I need to use a different alias to get colours.

On the Linux boxes:

+ classify: "append indicator (one of */=>@|) to entries" (to indicate directories, symlinks, etc.)
+ color: make the output in color (always)
+ quoting-style: show filenames as they are, so =File One.txt=, not ='File One.txt'= or =File\ One.txt=.  I'll put things in quotes if needed.

#+begin_src shell
if [[ $(uname) == "FreeBSD" ]] ; then
    alias ls='ls -F -G'
else # Presumably Linux
    alias ls='ls --classify --color --quoting-style=literal'
fi
#+end_src

Various short forms so I never have to actually type both letters of =ls=.

#+begin_src shell
alias l='ls'
alias la='l --all'
alias ll='l -l'
alias lla='l -l --all'
alias lsort='l -l -S --reverse'
#+end_src

**** w

Make =w= columns wider (very useful for hostnames).

#+begin_src shell
export PROCPS_FROMLEN=40
export PROCPS_USERLEN=12
#+end_src

**** More or less

I always want to use =less=, but I'm used to typing =more=.

#+begin_src shell
alias more='less'
alias mroe='more'
export PAGER=less
#+end_src

There is no =.lessrc=, so settings go in the =LESS= environment variable.  ([[https://www.topbug.net/blog/2016/09/27/make-gnu-less-more-powerful/][Source]].)

+ quit-if-one-screen:  if it all fits on screen, just show it and quit
+ ignore-case:  search are case-insensitive unless a capital letter is used
+ status-column:  show matches or where paging happened
+ LONG_PROMPT:  more verbose prompt
+ RAW-CONTROL-CHARS:  pass through raw ANSI colour escape sequences so colourizing can work
+ HILITE-UNREAD:  indicate first unread line after scrolling
+ tabs=4:  show a tab as four spaces
+ no-init:  don't clear screen after exiting; quit-if-one-screen needs this to be set
+ window=-4:  scroll by window size minus 4 lines, so there's overlap when scrolling

Pass through raw ANSI colour escape sequences.  In other words, make colourizing work.

#+begin_src shell
export LESS='--quit-if-one-screen --ignore-case --status-column --LONG-PROMPT --RAW-CONTROL-CHARS --HILITE-UNREAD --tabs=4 --no-init --window=-4'
#+end_src

=Lessfile= lets =less= open up tarred and gzipped files and so on and show what's inside.  If it's not installed, fall back to a script I wrote myself (see Lessfilter section below).

#+begin_src shell
if command -v lessfile > /dev/null 2>&1; then
    eval "$(lessfile)"
    # This sets LESSOPEN and will pick up on ~/.lessfilter.
else
    # Fall back to do the best we can.
    export LESSOPEN="| ~/.lessfilter %s"
fi
#+end_src

If any syntax highlighters are available, use them.  =Pygmentize= does more, but =source-highlight= is still good.

#+begin_src shell
if command -v pygmentize > /dev/null 2>&1; then
    export LESSCOLOURIZER="pygmentize -f terminal"
elif command -v source-highlight > /dev/null 2>&1; then
    export LESSCOLOURIZER="source-highlight --failsafe --infer-lang -f esc --style-file=esc.style -i"
fi
#+end_src

**** Small functions and helpers

Pretty-print directory tree.  I never use this, but it could be useful as a reference.

#+begin_src shell
function tree() {
    find "${1:-.}" -type d -print | sed -e 's:[ ]*/:|____:g;s:____|: |:g'
}
#+end_src

Set an "alert" alias for long running commands.  Use like this: =sleep 10; alert=.

#+begin_src shell
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
#+end_src

Swap file $1 with $2.

#+begin_src shell
function swap() {
    local TMPFILE=tmp.$$
    mv "$1" $TMPFILE
    mv "$2" "$1"
    mv $TMPFILE "$2"
}
#+end_src

Handy way to watch a file grow

#+begin_src shell
function monitor() {
    while true ; do
	clear
	tail "$1"
	sleep 10
    done
}
#+end_src

"| order" is very handy for counting duplicated lines in a file or listing.

#+begin_src shell
function order() {
    sort | uniq -c | sort -rn
}
#+end_src

Wipe all metadata from one or more images.

#+begin_src shell
function imagewipe() {
    for FILE in "$@"; do
	exiftool -all= "$FILE"
    done
}
#+end_src

Wipe all metadata from one or more PDFs.

#+begin_src shell
function pdfwipe() {
    for FILE in "$@"; do
	exiftool -all= "$FILE"
	qpdf --linearize --replace-input "$FILE"
    done
}
#+end_src

Sum a list of numbers.

#+begin_src shell
function colsum {
    paste -s -d+ | bc --
}
#+end_src

#+begin_example
$ (echo 1; echo 3; echo 5) | colsum
9
#+end_example

Copy files from somewhere to here, preserving all metadata (timestamp and such) as is.

#+begin_src shell
function get {
    rsync --archive --progress --human-readable "$@" .
}
#+end_src

**** Completions

Git.  Can be found as part of Git source.

#+begin_src shell
source ~/.git-completion.bash
#+end_src

Bash.  Requires bash-completion package.

#+begin_src shell
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    source /etc/bash_completion
fi
#+end_src

**** PATH

Here I build up the PATH bit by bit.  Put =/usr/local/bin= first (ahead of whatever is inherited from the system setting).

#+begin_src shell
PATH=/usr/local/bin:$PATH
#+end_src

Make sure the rootly paths are there.

#+begin_src shell
PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin
#+end_src

Emacs is run from source in =/usr/local/src/emacs=.

#+begin_src shell
PATH=/usr/local/src/emacs/src:$PATH
alias emacsclient="/usr/local/src/emacs/lib-src/emacsclient"
alias e="emacsclient --no-wait"
#+end_src

I run R from source in =/usr/local/src/R=.

#+begin_src shell
if [ -f /usr/local/src/R/R ] ; then
    PATH=/usr/local/src/R:$PATH
fi
#+end_src

Zotero needs to be [[https://www.zotero.org/support/installation][installed]] by hand.

#+begin_src shell
alias zotero="/usr/local/src/zotero/Zotero_linux-x86_64/zotero"
#+end_src

I put ircii's irc in ~/.irc/.

#+begin_src shell
PATH=$PATH:~/.irc/
#+end_src

Ruby: I use [[https://github.com/rbenv/rbenv][rbenv]] to handle Ruby.  If rbenv isn't there, it will default to the system Ruby.

#+begin_src shell
if [ -d ~/.rbenv/ ] ; then
    PATH=$HOME/.rbenv/bin:$PATH
    eval "$(rbenv init -)"
fi
#+end_src

Go (=go help gopath=).

#+begin_src shell
export GOPATH=~/.gopath
PATH=$PATH:$GOPATH/bin/
#+end_src

Pip (from Python).

#+begin_src shell
PATH=$PATH:~/.local/bin/
#+end_src

Rust.

#+begin_src shell
PATH=$PATH:~/.cargo/bin/
#+end_src

My own scripts, and finally, the current directory.

#+begin_src shell
PATH=$PATH:~/bin/:.
#+end_src

**** Local settings

There are some settings that I want just on a particular machine, and this makes that possible.  If the machine is named =dartagnan=, put machine-specific environment variables and settings in =~/.bash.dartagnan.rc=.

#+begin_src shell
if [ -f ~/.bash."$HOSTNAME".rc ] ; then
    . ~/.bash.$HOSTNAME.rc
fi
#+end_src

*** Dircolors (=dircolors.ansi-dark=) (imported)

https://github.com/seebi/dircolors-solarized/blob/master/dircolors.ansi-dark

"Solarized Color Theme for GNU ls (as setup by GNU dircolors)"

https://github.com/seebi/dircolors-solarized

Raw source:  [[https://raw.githubusercontent.com/seebi/dircolors-solarized/master/dircolors.ansi-dark][dircolors.ansi-dark]].

Imported copy: [[file:conforg/dotfiles/imported/dircolors.ansi-dark][conforg/dotfiles/imported/dircolors.ansi-dark]].

*** Logout (=.bash_logout=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/bash_logout
:END:

"When an interactive login shell exits, or a non-interactive login shell executes the exit builtin command, bash reads and executes commands
from the file =~/.bash_logout=, if it exists," says the =bash= man page.

The only command I have here is one I pasted in from I don't know where.  It clears the console when I log out, for privacy.  It's been years since I logged in through a console to run X, but who knows.

=SHLVL= is "incremented by one each time an instance of =bash= is started," so this runs if the shell being exited is not a sub-shell of another.

#+begin_src shell
if [ "$SHLVL" = 1 ]; then
    [ -x /usr/bin/clear_console ] && /usr/bin/clear_console -q
fi
#+end_src


** Git

*** Completion (imported)

https://github.com/git/git/blob/master/contrib/completion/git-completion.bash

*** Config (=.gitconfig=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/gitconfig
:END:

TODO:  Expand on what all this means.  Find a better way to handle the editor for cases where I'm on a remote server without Emacs running.

#+begin_src gitconfig
[include]
	path = ~/.gitconfig.local
[color]
	ui = auto
	pager = true
[column]
	ui = auto
[core]
	editor = emacsclient
[user]
	name = William Denton
	email = wtd@pobox.com
[push]
	default = current
[init]
  defaultBranch = main
[alias]
	hist = log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all
#+end_src

** LaTeX

*** ChkTeX (=.chktexrc=) (imported)

[[https://www.nongnu.org/chktex/][ChkTex]] is linter for LaTeX.  I think it complained about not having a configuration file when I first ran it, so I copied the default.

TODO:  did i tweak anything?  investigate.  for now, since it's so long and complicated, just leave it here.

Raw source: [[http://git.savannah.nongnu.org/cgit/chktex.git/plain/chktex/chktexrc][chktexrc]].

Imported copy: [[file:conforg/dotfiles/imported/chktexrc][conforg/dotfiles/imported/chktexrc]].

** Less

*** Lessfilter (=.lessfilter=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/lessfilter :shebang "#!/bin/bash"
:END:

See [[*More or less][More or less]] above for where this fits in to the =less= configuration.  This short script enables pre-processing of files before =less= displays them, which allows syntax highlighting and even extracting text from PDFs.  It's pretty amazing when you can run =less foo.pdf= and see what's in the PDF as plain text.

There are some requirements for this to work:

+ [[https://pygments.org/][Pygments]] (see what it can handle with =pygmentize -L lexers=)
+ [[https://www.gnu.org/software/src-highlite/][GNU source-highlight]]
+ [[https://poppler.freedesktop.org/][Poppler]] (for =pdftotext=)

To install them on Ubuntu, run this:

#+begin_src shell :tangle no
sudo apt install python-pygments source-highlight poppler-utils
#+end_src

=LESSCOLOURIZER= is defined in =.bashrc=.  It will be either =pygmentize= (preferred) or =source-highlight= (fallback, if it's installed).  Whichever is available, use it for everything except PDFs, where we use =pdftotext=.

This case statement defines which program handles which file types.  Pygmentize can handle many more than are here; this is just the ones I want.  My =.bashrc= doesn't get processed correctly, maybe because of escape sequences, so I left it out.

#+begin_src shell
if [ -v LESSCOLOURIZER ]; then
    case "$1" in
	.bash_|*.bat|*.bib|*.c|Changelog|*.diff|Gemfile|*.gemspec|*.h|*.html|*.ini|*.js|*.json|*.jsonld|\
	    Makefile|*.md|*.patch|*.php|*.pl|*.pm|*.py|Rakefile|*.rake|*.rb|*.R|*.Rprofile|*.rss|*.sh|*.sql|*.xsl|*.tex|*.toc|*.yaml|*.yml)
	    $LESSCOLOURIZER "$1" ;;
	,*.pdf)
	    if command -v pdftotext > /dev/null 2>&1 ; then pdftotext -layout "$1" -
	    else echo "No pdftotext available; try installing poppler-utils"; fi ;;
	,*)
	    # Pass through to lessfile
	    exit 1
    esac;
fi
#+end_src

Finally, if =LESSCOLOURIZER= is not set, hand off to =lessfile=.

#+begin_src shell
exit 1
#+end_src

** Nano

*** Config (=.nanorc=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/nanorc
:END:

#+begin_src nano
set fill -8
set nonewlines
set nowrap
set softwrap
set suspend
#+end_src

** R

[[https://www.r-project.org/][R]]'s web site says it "is a free software environment for statistical computing and graphics," which doesn't adequately describe how awesome it is.  I mainly use R through Emacs, but there are some settings that apply just to how R works that I want defined however R is run.

*** Rprofile (=.Rprofile=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/Rprofile
:END:

See also [[https://stackoverflow.com/q/1189759/854346][Expert R users, what's in your .Rprofile?]] from Stack Overflow.

First, hard code a nearby (to me) repo for [[https://cran.r-project.org/][CRAN]] packages.

TODO:  The mirror is also used in [[file:~/src/conforguration/conforguration.org::*Setup: R][Setup: R]] ... maybe I could put it into a bash environment variable in one place and get all the mentions from there?

#+begin_src R
r <- getOption("repos")
r["CRAN"] <- c("https://mirror.csclub.uwaterloo.ca/CRAN/")
options(repos = r)
rm(r)
#+end_src

I don't need to keep histories of everything.  I used to log everything to history files but never looked at them and discovered after a while that the directory was filled with 0-byte files.  I'll leave in the command to do that in case it's useful again one day.

#+begin_src R
Sys.setenv(R_HISTSIZE = '0')
## sink(file = paste('~/R/history/r-log-', strftime(Sys.time(), '%F %H:%M:%OS9'), sep = ''), split=T)
#+end_src

Should R automatically convert strings to factor variables in a data.frame?  No!  This is the default in 4.0 and up, but I'll leave it in for now.

#+begin_src R
options(stringsAsFactors = FALSE)
#+end_src

Override =q()= to not save by default.  Same as saying =q("no")=.

#+begin_src R
q <- function (save="no", ...) {
    quit(save=save, ...)
}
#+end_src

No menu popups:  use the console.

#+begin_src R
options(menu.graphics = FALSE)
#+end_src

Tab completion on =library()= and =require()=.

#+begin_src R
utils::rc.settings(ipck = TRUE)
#+end_src

Set the prompt?  I used to use a fancy "ℝ", but now just the default simple ">".  But I'll leave this here in case I want to go back.

#+begin_src R
## options(prompt="ℝ> ")
#+end_src

** Ruby

*** Gems (=.gemrc=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/gemrc
:END:

#+begin_src yaml
---
:verbose: true
:benchmark: false
:bulk_threshold: 1000
:update_sources: true
:backtrace: false
gem: --no-document
#+end_src

*** Pry (=.pryrc=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/pryrc
:END:

[[https://pry.github.io/][Pry]] "is a powerful alternative to the standard IRB shell for Ruby. It features syntax highlighting, a flexible plugin architecture, runtime invocation and source and documentation browsing."  See also the [[https://github.com/pry/pry/wiki/Pry-rc][pryrc documentation]].

The only setting here is to hook in [[https://github.com/awesome-print/awesome_print][awesome_print]] so that by default everything is nicely pretty-printed.

#+begin_src ruby
require "awesome_print"
AwesomePrint.pry!
#+end_src

*** Rubocop (=.rubocop.yml=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/rubocop.yml
:END:

[[https://github.com/rubocop/rubocop/][Rubocop]] "is a Ruby static code analyzer (a.k.a. linter) and code formatter."

I prefer using "double quotes" when quoting.  Everything else I leave as is.  When needed I can turn off a warning in the code itself.

#+begin_src yaml
Style/StringLiterals:
  EnforcedStyle: double_quotes
  SupportedStyles:
    - single_quotes
    - double_quotes

AllCops:
  NewCops: enable
#+end_src


** Signature

*** Personal (=.signature=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/signature
:END:

This is my personal sig.

#+begin_src text
--
William Denton
https://www.miskatonic.org/
Librarian, artist and licensed private investigator.
Toronto, Canada
#+end_src

*** Work (=.signature.work=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/signature.work
:END:

This is the sig I use at work.

#+begin_src text
William Denton <wdenton@yorku.ca> (he/him)
Associate Librarian: Scholarly Analytics / Mathematics & Statistics
York University (Toronto, Canada) https://www.library.yorku.ca/
#+end_src


** Tmux

*** Config (=.tmux.conf=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/tmux.conf
:END:

Start window numbering at 1.

#+begin_src tmux
set -g base-index 1
#+end_src

Status bar formatting.

#+begin_src tmux
set -g status-left-length 20
set -g status-left ""
set -g status-right "[Session: #S]"
set -g status-justify centre
#+end_src

Colours, taken from [[https://github.com/seebi/tmux-colors-solarized][tmux-colors-solarized]].  First, set the terminal type.

#+begin_src tmux
set -g default-terminal "screen-256color"
#+end_src

Default statusbar colors.

#+begin_src tmux
set-option -g status-bg black
set-option -g status-fg yellow
#+end_src

Pane number display.

#+begin_src tmux
set-option -g display-panes-active-colour blue
set-option -g display-panes-colour brightred
#+end_src

Clock.

#+begin_src tmux
set-window-option -g clock-mode-colour green
#+end_src
Bell.

#+begin_src tmux
set-window-option -g window-status-bell-style fg=black,bg=red
#+end_src

** X

*** XCompose (=.XCompose=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/XCompose
:END:

This allows the Compose key (for me Left-Ctrl, because I use CapLock as the Control key) to be used in Emacs.

#+begin_src XCompose
include "%L"
#+end_src

(See also this [[https://github.com/kragen/xcompose][xcompose]] project at GitHub that has a massive .XCompose file with and an enormous set of key combinations.  More than I need right now, but maybe one day.)

*** Xmodmap (=.xmodmaprc=)
:PROPERTIES:
:header-args: :tangle conforg/dotfiles/mine/xmodmaprc
:END:

Do I actually need this?  I'm not loading it in.  Is it being caught automatically?

TODO:  Try disabling it and see what happens.

#+begin_src xmodmap
keysym Home = Insert
keysym End = Insert
#+end_src

* Emacs

** Requirements

You can't build anything from source without making sure all the necessary utilities and libraries are there first.  Once done, this will never need to be run again.  (Unless the version of GCC changes, in which case a new =libgccjit-xx-dev= will be needed.  Check the current version with =gcc --version=.)  These requirements go beyond the bare minimum in order to make native compilation work (on Ubuntu 22.04).

#+begin_src shell :tangle conforg/scripts/emacs-install-requirements.sh :shebang "#!/bin/bash"
sudo apt-get build-dep emacs
sudo apt-get install libjansson-dev valgrind fonts-firacode libgccjit0 libgccjit-11-dev libgtk-3-dev
## On Linux Mint, at least, these are not installed when the above is done.  Curious.
## On other systems, it can't hurt.
sudo apt-get install texinfo libxpm-dev libjpeg-dev libgif-dev libtiff-dev libtinfo-dev
#+end_src

** Install for personal use

First get the source for Emacs and compile it.

#+begin_src shell :tangle conforg/scripts/emacs-install-personal.sh :shebang "#!/bin/bash"
cd /usr/local/src/
git clone https://git.savannah.gnu.org/git/emacs.git
cd emacs
./autogen.sh
./configure --with-pgtk && make -j 8
#+end_src

Then do the same for Org.

#+begin_src shell :tangle conforg/scripts/emacs-install-personal.sh :shebang "#!/bin/bash"
cd /usr/local/src/
git clone https://git.savannah.gnu.org/git/emacs/org-mode.git
cd org-mode
make autoloads
make
#+end_src

Finally, get my Emacs configuration (which is not here in Conforguration).  It will be cloned into =~/.emacs.d/=.  (Requires a GitHub account when done this way.)

#+begin_src shell :tangle conforg/scripts/emacs-install-personal.sh :shebang "#!/bin/bash"
cd
git clone git@github.com:wdenton/.emacs.d.git
# Or if you don't want to use a GitHub account:
# git clone https://github.com/wdenton/.emacs.d.git
echo "Now run emacs, and say no when asked about a location for abbrev_defs."
#+end_src

Running ~emacs~ the first time will download and install all the packages needed, but some setting about =abbrevs= is misordered so it will ask a question it doesn't need to ask.  Saying no makes everything work.

It's probably best to quit Emacs and restart after this, but you don't actually need to.

** Update

This is a simple script that pulls down the updated source for Emacs and Org and compiles them.  If something goes wrong with the Emacs compile you might need to do =make clean= or =make distclean= or =make extraclean= and then try again.

If there are compilation problems then running =make maintainer-clean= in the Emacs source directory will probably fix it by resetting everything.

#+begin_src shell :tangle conforg/scripts/emacs-update.sh :shebang "#!/bin/bash"
cd /usr/local/src/emacs/
git pull
./configure --with-json --with-pgtk && make -j 8
cd ../org-mode/
make -j 8 update
#+end_src

#+begin_src shell :tangle conforg/scripts/emacs-update-aot.sh :shebang "#!/bin/bash"
cd /usr/local/src/emacs/
git pull
./configure --with-json --with-pgtk --with-native-compilation=aot && make -j 8
cd ../org-mode/
make -j 8 update
#+end_src

* R

For running a personal version of R, ~PATH~ needs to include ~/usr/local/src/R~, but my bashrc will set that up if it's there.

Change the version number as needed, then tangle and run the install script again.

#+NAME: R_VERSION
| 4.2.2 |

** Requirements

The first line of requirements may be needed for R 3.3.  The ~topicmodels~ package requires the GNU Scientific Library.  Once done, this doesn't need to be run again.  Sync and run the script on machines as necessary.

#+begin_src shell :tangle conforg/scripts/r-install-requirements.sh :shebang "#!/bin/bash"
sudo apt install libbz2-dev liblzma-dev libxml2-dev libpcre2-dev libpcre3-dev fonts-inconsolata
sudo apt install xorg-dev gfortran libreadline-dev libcurl4-openssl-dev libssl-dev libgsl-dev curl libcurl4-openssl-dev libudunits2-dev libgdal-dev
sudo apt build-dep r-base
mkdir -p ~/R/history/
mkdir -p ~/.R/lintr_cache/
mkdir -p /usr/local/src/R
#+end_src

** Noweb setup

Whether R is being installed system-wide or just for personal use, this code will be run.

#+begin_src :shell :noweb-ref r_source_code_present_and_compiled
cd $(dirname "$0")
SCRIPTS_DIR=$(pwd)
MIRROR="https://mirror.csclub.uwaterloo.ca/CRAN/"
cd /usr/local/src/R
#+end_src

If the source has been untarred already, wipe that directory because we want to start fresh.

#+begin_src :shell :noweb-ref r_source_code_present_and_compiled
if [ -d "/usr/local/src/R/R-${R_VERSION}" ]; then
  echo "Removing old source directory ..."
  rm -r R-${R_VERSION}
fi
#+end_src

If the source tarball is there, use it, otherwise download.  The =R_MAJOR= variable is there because we need to know the major version number, so we can get to e.g. base/R-4 to download 4.0.4.

#+begin_src :shell :noweb-ref r_source_code_present_and_compiled
if ! [ -f "R-${R_VERSION}.tar.gz" ]; then
  echo "Downloading R-${R_VERSION} tarball ..."
  R_MAJOR=${R_VERSION:0:1}
  curl -O $MIRROR/src/base/R-${R_MAJOR}/R-${R_VERSION}.tar.gz
else
  echo "Using existing R-${R_VERSION} tarball ..."
fi
#+end_src

Now uncompress, configure and compile.  This could take a while.

#+begin_src :shell :noweb-ref r_source_code_present_and_compiled
echo "Uncompressing ..."
tar xzvf R-$R_VERSION.tar.gz

echo "Compiling ..."
cd R-$R_VERSION
./configure --enable-R-shlib
make && make check
#+end_src

** Install for personal use

Here we set up symlinks to point to the ~R~ and ~Rscript~ executables, then source ~.bashrc~ to refresh ~$PATH~ to notice them and put that ~Rscript~ first, which makes the package installation work.

First, get R downloaded and compiled.

#+begin_src shell :tangle conforg/scripts/r-install-personal.sh :shebang "#!/bin/bash" :noweb yes :var R_VERSION=R_VERSION
<<r_source_code_present_and_compiled>>
#+end_src

Next, set up the aliases for it in =/usr/local/src/R/=.  To be sure they work, reload bash to pick up on the PATH.

#+begin_src shell :tangle conforg/scripts/r-install-personal.sh :shebang "#!/bin/bash" :noweb yes :var R_VERSION=R_VERSION
cd /usr/local/src/R/
rm -f R Rscript
ln -s R-${R_VERSION}/bin/R R
ln -s R-${R_VERSION}/bin/Rscript Rscript

source ~/.bashrc
#+end_src

Finally, install the packages.

#+begin_src shell :tangle conforg/scripts/r-install-personal.sh :shebang "#!/bin/bash" :noweb yes :var R_VERSION=R_VERSION
cd $SCRIPTS_DIR
./r-install-packages.sh
#+end_src

** Install system-wide

R packages need to be installed in a full root login.  There's probably a way to do this with ~sudo -i~, but I can't figure it out, so I do it this convoluted way.  It works, but if there's a better way, please let me know.  Here we become root, then get back to the directory where the package installation script is so we can run it.

#+begin_src shell :tangle conforg/scripts/r-install-system.sh :shebang "#!/bin/bash" :noweb yes :var R_VERSION=R_VERSION
<<r_source_code_present_and_compiled>>
sudo make install

sudo su - -c "cd $SCRIPTS_DIR; ./r-install-packages.sh"
#+end_src

** Packages

There are quite a few R packages I want installed by default, including of course the [[https://www.tidyverse.org/][Tidyverse]], which I greatly admire.  The packages are all in this next table.  Add to (and resort) as needed.

# TODO: Catch any errors that come up when installing the packages, and bail out with a warning.
# The problem could be that a dependency is missing (for example for GIS packages, which use
# programs and libraries installed on the system)
# See "How do I make install.packages return an error if an R package cannot be installed?" (https://stackoverflow.com/q/26244530)

#+NAME: r_packages
| RCurl         |
| RSQLite       |
| arules        |
| arulesViz     |
| cluster       |
| dbplyr        |
| devtools      |
| docopt        |
| flexdashboard |
| fpc           |
| fs            |
| geonames      |
| geosphere     |
| ggrepel       |
| ggridges      |
| ggvis         |
| hms           |
| igraph        |
| knitr         |
| lintr         |
| lubridate     |
| mapproj       |
| maps          |
| maptools      |
| osmdata       |
| readODS       |
| readxl        |
| remotes       |
| rgeos         |
| roxygen2      |
| seriation     |
| sf            |
| shiny         |
| skimr         |
| testthat      |
| tidyverse     |
| tm            |
| topicmodels   |
| usethis       |
| xlsx          |

Now we need to transform that list into some shell commands.  First, we're going to turn the list into a shell variable, =package_list=, with a neat [[https://stackoverflow.com/a/9429887/854346][array join tip]] I saw on Stack Overflow.  This code block sets up the variable in another code block.  (Make sure the name =packages-list-variable= is set or the noweb tangling won't work.)

#+begin_src shell :results output :var pkgs=r_packages :results code
echo -n 'package_list="'
IFS=" " ; echo -n "${pkgs[*]}"
echo -n '"'
#+end_src

#+NAME: packages-list-variable
#+RESULTS:
#+begin_src shell
package_list="RCurl RSQLite arules arulesViz cluster dbplyr devtools docopt flexdashboard fpc fs geonames geosphere ggrepel ggridges ggvis hms igraph knitr lintr lubridate mapproj maps maptools osmdata readODS readxl remotes rgeos roxygen2 seriation sf shiny skimr testthat tidyverse tm topicmodels usethis xlsx"
#+end_src

And the above code block is included in the one below with noweb.

#+begin_src shell :tangle conforg/scripts/r-install-packages.sh :shebang "#!/bin/bash" :noweb yes
<<packages-list-variable>>
for pkg in $package_list
do
    Rscript --vanilla -e "install.packages('$pkg', repos=c('https://mirror.csclub.uwaterloo.ca/CRAN/'))"
done
Rscript --vanilla -e "devtools::install_github('yorkulibraries/yulr')"
#+end_src

When tangled, the script will have the full =package_list= definition with all the packages, and it loops through them all, installing one by one (with dependencies, where required).  There are a lot of packages, so this will take a while.

* Ruby

#+NAME: RUBY_VERSION
| 3.2.0 |

** Requirements

Make sure some necessities are in place before trying to build from source.

#+begin_src shell :tangle conforg/scripts/ruby-install-requirements.sh :shebang "#!/bin/bash"
sudo apt-get build-dep ruby
sudo apt-get install libreadline-dev libsqlite3-dev libyaml-dev
#+end_src

** Install (or upgrade) rbenv

This script installs [[https://github.com/rbenv/rbenv][rbenv]] if it isn't already in place; if it is, it updates it.  It checks to see if =~/.rbenv/= exists; if it does, =rbenv= is installed, so it just tries to update it; if not, it installs it.

#+begin_src shell :tangle conforg/scripts/ruby-rbenv.sh :shebang "#!/bin/bash"
if [[ -d ~/.rbenv ]]; then
    echo "Upgrade if possible"
    cd ~/.rbenv/
    git pull
    cd plugins/ruby-build
    git pull
else
    echo "Installing"
    git clone https://github.com/rbenv/rbenv.git ~/.rbenv
    git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build
    source ~/.bashrc
fi
#+end_src

This can be called with noweb by source blocks below to install =rbenv= on a remote machine.

#+NAME: ruby-rbenv-remotely
#+begin_src shell
ssh ${hostname} "conforg/scripts/ruby-rbenv.sh"
#+end_src

** Install with rbenv for personal use

#+begin_src shell :tangle conforg/scripts/ruby-install-personal.sh :shebang "#!/bin/bash" :var RUBY_VERSION=RUBY_VERSION
rbenv install --verbose $RUBY_VERSION
rbenv global $RUBY_VERSION
~/conforg/scripts/ruby-install-gems.sh
echo "Now run bundle install where needed."
#+end_src

#+NAME: ruby-install-personal-remotely
#+begin_src shell
ssh ${hostname} "conforg/scripts/ruby-install-personal.sh"
#+end_src

** Install system-wide

#+begin_src shell :tangle conforg/scripts/ruby-install-system.sh :shebang "#!/bin/bash" :var RUBY_VERSION=RUBY_VERSION
mkdir -p /usr/local/src/ruby
cd /usr/local/src/ruby

# The 3.0.2.tar.gz tarball is in the 3.0/ directory, for example.
MINOR_VERSION=$(echo ${RUBY_VERSION} | sed 's/\.[[:digit:]]$//')

curl -LO https://cache.ruby-lang.org/pub/ruby/${MINOR_VERSION}/ruby-${RUBY_VERSION}.tar.gz
tar xzvf ruby-${RUBY_VERSION}.tar.gz
cd ruby-${RUBY_VERSION}

./configure
make

sudo make install
sudo ~/conforg/scripts/ruby-install-gems.sh

echo "Now run bundle install where needed."
#+end_src

#+NAME: ruby-install-system-remotely
#+begin_src shell
ssh ${hostname} "conforg/scripts/ruby-install-system.sh"
#+end_src

** Install gems

This works like the R packages do.  First, a list of gems I want installed by default.

#+NAME: ruby_gems
| awesome_print |
| bundler       |
| docopt        |
| http          |
| marc          |
| nokogiri      |
| pry           |
| pry-doc       |
| rubocop       |
| rubyul        |
| sqlite3       |

Now transform that list into some shell commands into a shell variable, GEM_LIST.  This code block generates the next one.

#+begin_src shell :results output :var gems=ruby_gems :results code
echo -n 'GEM_LIST="'
IFS=" " ; echo -n "${gems[*]}"
echo -n '"'
#+end_src

#+NAME: gem-list-variable
#+RESULTS:
#+begin_src shell
GEM_LIST="awesome_print bundler docopt http marc nokogiri pry pry-doc rubocop rubyul sqlite3"
#+end_src

And the above code block is included in the one below with noweb.

#+begin_src shell :tangle conforg/scripts/ruby-install-gems.sh :shebang "#!/bin/bash" :noweb yes
<<gem-list-variable>>
for gem in $GEM_LIST
do
    gem install $gem
done
#+end_src

* Tor

#+NAME: TOR_VERSION
| 0.4.7.12 |

I run a [[https://www.torproject.org/][Tor]] relay (a guards, not an exit point).  These scripts let me update and run it, but this is not good enough for someone else to set up a new relay of their own.  I may add more later.

** Requirements

Make sure some necessities are in place before trying to build from source.

#+begin_src shell :tangle conforg/scripts/tor-install-requirements.sh :shebang "#!/bin/bash"
sudo apt install libevent-dev libssl-dev libcap-dev liblzma-dev libzstd-dev libseccomp-dev libscrypt-dev
sudo apt install speedometer tmux
mkdir -p /usr/local/src/tor/
#+end_src

** Install

#+begin_src shell :tangle conforg/scripts/tor-install-system.sh :shebang "#!/bin/bash" :var TOR_VERSION=TOR_VERSION
cd /usr/local/src/tor/
curl -LO https://dist.torproject.org/tor-${TOR_VERSION}.tar.gz
tar --extract --verbose --gunzip --file tor-${TOR_VERSION}.tar.gz
cd tor-${TOR_VERSION}
./configure && make && sudo make install
echo "Now run ~/conforg/scripts/tor-run.sh"
#+end_src

#+NAME: tor-install-system-remotely
#+begin_src shell
ssh ${hostname} "conforg/scripts/tor-install-system.sh"
#+end_src

** Script to run and monitor Tor

This runs Tor in a [[https://github.com/tmux/tmux/wiki][Tmux]] session with a window where the =speedometer= program is showing how much bandwidth is in use.  Logging in and running =tmux attach -t tor= shows what's going on, then =C-b d= detaches but leaves everything running.

First, if one of these is already running, kill it and everything inside.  Need to wait at least 30 seconds for Tor to shut down nicely.

#+begin_src shell :tangle conforg/scripts/tor-run.sh :shebang "#!/bin/bash"
if tmux has-session -t tor
 then
     echo "Session tor exists; killing it nicely ..."
     tmux send-keys -t tor:1 "C-c"
     tmux send-keys -t tor:2 "C-c"
     sleep 35
     tmux kill-window -t tor:1
     tmux kill-window -t tor:2
 fi
#+end_src

Now start a new session with two windows in it, one running Tor and one running the =speedometer= visualization.  Being able to script Tmux like this makes it very powerful.

By default, =speedometer= will show traffic on the =wlan0= interface.  To use another one, set the TOR_IFACE environment variable in =~/.bash.${HOSTNAME}.rc=, like so: =export TOR_IFACE=ens160=.

#+begin_src shell :tangle conforg/scripts/tor-run.sh
echo "Starting tor session ..."

tmux new-session -d -s "tor"

if [[ -z $TOR_IFACE ]]; then
   TOR_IFACE=wlan0
fi

tmux new-window -t tor:2
tmux send-keys -t tor:2 "speedometer -t ${TOR_IFACE} -r ${TOR_IFACE} -l -m 1048576" "C-m"

tmux select-window -t 1
tmux send-keys -t tor:1 "tor" "C-m"
#+end_src

Put this in the crontab to bring up Tor automatically when the machine reboots:

#+begin_example
@reboot ~/conforg/scripts/tor-run.sh
#+end_example

If you defined TOR_IFACE specially, do this:

#+begin_example
@reboot source ~/.bash.${HOSTNAME}.rc; ~/conforg/scripts/tor-run.sh
#+end_example

* Machines

** localhost

#+begin_src shell :results output
install/install.sh
#+end_src

#+RESULTS:
#+begin_example
mine
   abcde.conf
   bash_logout
   bash_profile
   bashrc
   gemrc
   gitattributes
   gitconfig
   lessfilter
   nanorc
   pryrc
   Rprofile
   rubocop.yml
   signature
   signature.work
   tmux.conf
   XCompose
   xmodmaprc
imported
   chktexrc
   dircolors.ansi-dark
   git-completion.bash
#+end_example

** music
:PROPERTIES:
:header-args: :var hostname="music"
:END:

#+begin_src shell :results silent :noweb yes
<<install-conforg-remotely>>
#+end_src

*** Install Emacs remotely one way

#+begin_src shell :dir /scp:wtd@music:conforg/scripts/ :results silent
# ./emacs-install-requirements.sh
./emacs-install-personal.sh
#+end_src

*** Install Ruby remotely the other way

#+begin_src shell :results silent :noweb yes
<<ruby-rbenv-remotely>>
#+end_src

#+begin_src shell :results silent :noweb yes
<<ruby-install-personal-remotely>>
#+end_src

Or log in to the machine itself and run the scripts there.

** pihole
:PROPERTIES:
:header-args: :var hostname="pihole"
:END:

#+begin_src shell :results silent :noweb yes
<<install-conforg-remotely>>
#+end_src

** tor
:PROPERTIES:
:header-args: :var hostname="tor"
:END:

#+begin_src shell :results silent :noweb yes
<<install-conforg-remotely>>
#+end_src

** pair
:PROPERTIES:
:header-args: :var hostname="pair"
:END:

#+begin_src shell :results silent :noweb yes
<<install-conforg-remotely>>
#+end_src

** shell3
:PROPERTIES:
:header-args: :var hostname="shell3"
:END:

#+begin_src shell :results silent :noweb yes
<<install-conforg-remotely>>
#+end_src

** wdenton2
:PROPERTIES:
:header-args: :var hostname="wdenton2"
:END:

#+begin_src shell :results silent :noweb yes
<<install-conforg-remotely>>
#+end_src

** orez
:PROPERTIES:
:header-args: :var hostname="orez"
:END:

#+begin_src shell :results silent :noweb yes
<<install-conforg-remotely>>
#+end_src
