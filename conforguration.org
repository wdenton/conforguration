#+TITLE: Conforguration
#+AUTHOR: William Denton
#+EMAIL: wtd@pobox.com

#+STARTUP: showall entitiespretty inlineimages
#+OPTIONS: toc:nil ^:nil

# These variables are hardcoded now.  Could maybe abstract them out later.
# +PROPERTY: header-args :var script_dir="conforguration_scripts" :var dotfiles_dir="dotfiles"

# Could work with https://github.com/cbowdon/daemons.el/blob/master/README.org ?

This has my dot files and helper scripts to install Emacs, R and Ruby from source.  There may be more in the future.

If you're looking at this on GitHub, the BEGIN and END source block wrappers are hidden, so you can't see the parameters.  Look at the raw version of the file, or clone the repository and load it into Emacs, to read it properly.

Related:  There are a lot of dot files in [[https://github.com/webpro/awesome-dotfiles][awesome-dotfiles]], and it seems [[https://github.com/aldrichtr/tangld][tangld]] is a similar project to this.

* Initialize

Create =/usr/local/src/= and make it owned by oneself (on Debian-like systems, at least). This is where all source code will be downloaded and compiled.

#+begin_src shell :tangle conforguration_scripts/initialize.sh :shebang "#!/bin/bash"
sudo mkdir -p /usr/local/src/
sudo chown $USER:$USER /usr/local/src
#+end_src

* Dot files

** Introduction

Almost all of my "dot files" ([[https://en.wikipedia.org/wiki/Run_commands][run command files]], containing configuration instructions for different programs) are in this Org file.  Most lines have a comment explaining what they are for, and when I've cribbed something from some web page or another's dot file (which is frequent), I've credited it where possible.

There are two kinds of dot files: "mine" and "imported."  Most are "mine," and are handled completely in this Org file.  The "imported" ones are copied completely from elsewhere, usually some software distribution that has one particular file I need.  Right now there are only three imported files:  one is a script that does completion for Git in bash, one makes ls listings be in colour, and the third, which configures a LaTeX linter, really should be under "mine" but it's so long I can't be bothered right now.

The files that are "mine" are all tangled from this Org file.  The "imported" ones are copied as is.

If you need some special environment variables on a machine, put them in ~.bash.$HOSTNAME.rc~, as described at the bottom of ~.bashrc~.  That's one way of setting up private environment variables that hold passwords or API tokens.

A note about languages specified in the source blocks:  the language setting is required, but it doesn't have to be a known and supported language.  So in order for the =.tmuxrc= to be tangled, for example, I say it has the language "tmux," which doesn't exist but makes it work.

** Installing the dot files

*** Tangle everything

Before anything else, make sure that everything has been tangled, so all the dot files and install scripts are up to date.

#+begin_src elisp :results silent
(org-babel-tangle)
#+end_src

*** Script to copy the dot files into =~/dotfiles/=

Gather all the dot files and the install script into the =~/dotfiles/= directory.  It's easiest to have them all there because they can then be pushed to other machines, instead of trying to use Conforguration over there.  Of course it's possible to run Conforguration on another machine and treat it as localhost when logged in there, instead of pushing to it.

First, move into the directory where the script is.  There is [[https://stackoverflow.com/questions/59895/how-can-i-get-the-source-directory-of-a-bash-script-from-within-the-script-itsel][much discussion on Stack Overflow]] about the best way to do this, but this works.  It means you can call the script from anywhere.

#+begin_src shell :tangle dotfiles/copy-dotfiles.sh :shebang "#!/bin/bash" :eval no
cd "$(dirname "$0")"
#+end_src

Then copy all the files I want from Conforguration into =~/dotfiles/=.

#+begin_src shell :tangle dotfiles/copy-dotfiles.sh :shebang "#!/bin/bash" :eval no
mkdir -p ~/dotfiles/mine/ ~/dotfiles/imported/
cp -p mine/* ~/dotfiles/mine/
cp -p imported/* ~/dotfiles/imported/
cp -p link-dotfiles.sh ~/dotfiles/
#+end_src

*** Script to create symlinks for the dot files

Once all the dot files are in =~/dotfiles/=, we need a script to set them up in the home directory.  This is done by making symlinks.

First, to be safe, again move into the directory where the script is run.

#+begin_src shell :tangle dotfiles/link-dotfiles.sh :shebang "#!/bin/bash" :eval no
cd "$(dirname "$0")"
# echo "PWD is " $(pwd)
#+end_src

The dot files are in two directories:  =mine= and =imported=.  Go into each directory and make a symbolic link (specifying the full path) to =file= from =~/.file=.  In other words, =~/.bashrc= is a symlink to the =mine/bashrc= here.

(To be absolutely safe, all the filenames should be in double quotes, but there are no spaces or strange characters in my filenames, so I'm going to leave that out because it messes up the syntax highlighting.)

#+begin_src shell :tangle dotfiles/link-dotfiles.sh :shebang "#!/bin/bash" :eval no
for dir in mine imported; do
    echo $dir
    cd $dir
    for file in *; do
	echo "  " $file
	rm -f ~/.${file}
	ln -s ~/dotfiles/${dir}/${file} ~/.${file}
    done
    cd ..
done
#+end_src

Finally, make sure that the =.bash_profile= is the real =.profile=, so no errant leftover =.profile= can get in the way.

#+begin_src shell :tangle dotfiles/link-dotfiles.sh :shebang "#!/bin/bash" :eval no
rm ~/.profile
ln -s ~/.bash_profile ~/.profile
#+end_src

Once this is run you need to open up a new shell, our =source ~/.bashrc=, to see any changes.

*** Noweb for installing remotely

TODO:  Explain.

#+NAME: install-dotfiles-remotely
#+begin_src shell
rsync --archive --compress --delete ~/dotfiles/ ${hostname}:dotfiles/
ssh ${hostname} "dotfiles/link-dotfiles.sh"
#+end_src

*** Install!

The script can be run here or from the command line (called from anywhere---you don't need to be in the same directory).

#+begin_src shell :results silent
dotfiles/copy-dotfiles.sh
~/dotfiles/link-dotfiles.sh
#+end_src

** Abcde

*** Config (=.abcde.conf=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/abcde.conf
:END:

Abcde is [[https://abcde.einval.com/wiki/][A Better CD Encoder]].  With one program I can digitize a CD all in one go, and with luck get some metadata from [[https://musicbrainz.org/][MusicBrainz]].  This configuration I [[https://www.andrews-corner.org/abcde/][lifted from Andrew's Corner]] and left alone.  All I want to do is turn the CD into FLAC files, and with this all I have to do is run =abcde= without any options.  Then I use [[https://wiki.gnome.org/Apps/EasyTAG][EasyTAG]] to clean up the metadata.

LOWDISK "conserves disk space by encoding tracks immediately after reading them" (I quote from the man page) which may not be too big a deal, but:  "Note that this option may also help when reading a CD with errors. This is because on a scratchy disk reading is quite timing sensitive and this option reduces the background load on the system which allows the ripping program more precise control."  That's useful.

#+begin_src abcde
LOWDISK=y
#+end_src

Where to retrieve track information.

#+begin_src abcde
CDDBMETHOD=musicbrainz
#+end_src

Make a local cache of CDDB entries and then volunteer to use these entries when and if they match the CD.

#+begin_src abcde
CDDBCOPYLOCAL="y"
CDDBLOCALDIR="$HOME/.cddb"
CDDBLOCALRECURSIVE="y"
CDDBUSELOCAL="y"
#+end_src

Specify the encoder to use for FLAC. In this case flac is the only choice.

#+begin_src abcde
FLACENCODERSYNTAX=flac
#+end_src

Specify the path to the selected encoder.  It's in my PATH so I don't need to specify a full path.

#+begin_src abcde
FLAC=flac
#+end_src

Specify your required encoding options here. Multiple options can be selected as '--best --another-option' etc. Overall bitrate is about 880 kbs/s with level 8.

#+begin_src abcde
# FLACOPTS='-s -e -V -8'
FLACOPTS='--silent --exhaustiv-model-search --verify --compression-level-8'
#+end_src

Output type for FLAC.

#+begin_src abcde
OUTPUTTYPE="flac"
#+end_src

The CD ripping program to use. There are a few choices here: cdda2wav, dagrab, cddafs (Mac OS X only) and flac.

#+begin_src abcde
CDROMREADERSYNTAX=cdparanoia
#+end_src

Specify the location of the ripping program and pass any extra options.

#+begin_src abcde
CDPARANOIA=cdparanoia
CDPARANOIAOPTS="--never-skip=40"
#+end_src

Path to the CD identification program.

#+begin_src abcde
CDDISCID=cd-discid
#+end_src

The base location for the encoded music files.

#+begin_src abcde
OUTPUTDIR="$HOME/Music"
#+end_src

Default actions that abcde will take.

#+begin_src abcde
ACTIONS=cddb,playlist,read,encode,tag,move,clean
#+end_src

Decide here how you want the tracks labelled for a standard 'single-artist', multi-track encode and also for a multi-track, 'various-artist' encode:

#+begin_src abcde
OUTPUTFORMAT='${OUTPUT}/${ARTISTFILE}-${ALBUMFILE}/${TRACKNUM}.${TRACKFILE}'
VAOUTPUTFORMAT='${OUTPUT}/Various-${ALBUMFILE}/${TRACKNUM}.${ARTISTFILE}-${TRACKFILE}'
#+end_src

Decide here how you want the tracks labelled for a standard 'single-artist',  single-track encode and also for a single-track 'various-artist' encode.  (Create a single-track encode with 'abcde -1' from the command line.)

#+begin_src abcde
ONETRACKOUTPUTFORMAT='${OUTPUT}/${ARTISTFILE}-${ALBUMFILE}/${ALBUMFILE}'
VAONETRACKOUTPUTFORMAT='${OUTPUT}/Various-${ALBUMFILE}/${ALBUMFILE}'
#+end_src

Create playlists for single and various-artist encodes.

#+begin_src abcde
PLAYLISTFORMAT='${OUTPUT}/${ARTISTFILE}-${ALBUMFILE}/${ALBUMFILE}.m3u'
VAPLAYLISTFORMAT='${OUTPUT}/Various-${ALBUMFILE}/${ALBUMFILE}.m3u'
#+end_src

The man page says, "mungefilename() is an abcde shell function that can be overridden via abcde.conf. It takes CDDB data as $1 and outputs the resulting filename on stdout."  This one takes out dots preceding the album name, and removes other difficult characters.

#+begin_src abcde
mungefilename ()
{
  echo "$@" | sed -e 's/^\.*//' | tr -d ":><|*/\"'?[:cntrl:]"
}
#+end_src

Use two encoders simultaneously.

#+begin_src abcde
MAXPROCS=2
#+end_src

Number tracks as 01 and 02, not 1 and 2.

#+begin_src abcde
PADTRACKS=y
#+end_src

Make output more verbose.  Most verbose is 2.

#+begin_src abcde
EXTRAVERBOSE=1
#+end_src

Add a comment?  No.

#+begin_src abcde
COMMENT=""
#+end_src

Finally, eject the CD when done.

#+begin_src abcde
EJECTCD=y
#+end_src


** Bash

My shell is [[https://www.gnu.org/software/bash/][Bash]].  I've looked at other ones, and some do fancy impressive things, but my shell needs are fairly simple.

I've forgotten the intricacies of when a =.profile= is used and how interactive and non-interactive shells handle things differently, but what I have works for me.

*** Profile (=.bash_profile=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/bash_profile
:END:

First, I set [[https://www.gnu.org/software/gettext/manual/html_node/Locale-Environment-Variables.html#Locale-Environment-Variables][locale environment variables]] to say I want to use English, specifically Canadian English.

#+begin_src shell
export LANG=en_CA.UTF-8
export LC_ALL=en_CA.UTF-8
#+end_src

If these locales aren't available---perhaps because this is running on a new machine---then I need to run these to configure it.  This is only necessary once.

#+begin_src shell :tangle no
sudo locale-gen en_CA.UTF-8
sudo update-locale LANG=en_CA.UTF-8
#+end_src

Then the =.bashrc= is processed.

#+begin_src shell
source ~/.bashrc
#+end_src

*** Config (=.bashrc=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/bashrc
:END:

**** File permissions

Set the default "user file-created mask" to 022, so that by default regular files are created 644 (=-rw-r--r--=) and executables 755 (=-rwxr-xr-x=)

#+begin_src shell
umask 022
#+end_src

**** Editing

My preferred editor is Emacs (of course) but I define these so that if someone pops up an editor it doesn't use vi.

#+begin_src shell
export EDITOR=nano
export VISUAL=nano
#+end_src

**** Web

The only thing I ever use that pays attention to =WWW_HOME= is lynx, I think, but [[https://duckduckgo.com/][DuckDuckGo]] is a good default first page to load if something is going to try.

#+begin_src shell
export WWW_HOME=https://duckduckgo.com/
#+end_src

**** History

Don't put duplicate lines or lines starting with space in the history.

#+begin_src shell
HISTCONTROL=ignoreboth
#+end_src

The commands listed here will be ignored by history.  If I run =cd= and then hit <up>, =cd= doesn't reappear.

#+begin_src shell
HISTIGNORE="cd:df:pwd:[bf]g:exit:history"
#+end_src

Set the number of commands to remember, and the file size of =.bash_history=.

#+begin_src shell
HISTSIZE=10000
HISTFILESIZE=1000000
#+end_src

Append to the history file, don't overwrite it.

#+begin_src shell
shopt -s histappend
#+end_src

Append and reload the history after each command, so the full history is available in all shells simultaneously.  But watch out!  If I'm being active in different shells at the same time then I need to be careful about which command reappears with <up>.

#+begin_src shell
PROMPT_COMMAND="history -a; history -n"
#+end_src

**** Terminals

Check the terminal window size after each command and, if necessary, update the values of LINES and COLUMNS.

#+begin_src shell
shopt -s checkwinsize
#+end_src

Puts wtd@hostname (or whatever) in the title bar of the terminal window.  For it to change when you login to another machine, it needs to be in your =.bashrc= there too.  Very handy when using tabs.

#+begin_src shell
if [ "$TERM" = 'xterm' ] || [ "$TERM" = 'rxvt' ] || [ "$TERM" = 'xterm-256color' ]
then
    export PROMPT_COMMAND='echo -ne "\033]2;"`whoami`@`hostname -s`"\007"'
fi
#+end_src

**** Solarized theme

Apply a [[https://ethanschoonover.com/solarized/][Solarized]] theme to color ls listings.  Taken from [[https://github.com/seebi/dircolors-solarized][dircolors-solarized]].  I'm using =dircolors.ansi-dark=.

#+begin_src shell
if command -v dircolors > /dev/null 2>&1
then
    eval "$(dircolors ~/.dircolors.ansi-dark)"
fi
#+end_src
# Also use solarized theme in GNOME terminal
# See https://github.com/sigurdga/gnome-terminal-colors-solarized

**** Prompt

The [[https://xta.github.io/HalloweenBash/][Bash Profile Generator]] is very useful here.  For colours, see also [[https://tldp.org/HOWTO/Bash-Prompt-HOWTO/x329.html][the colours section]] from this ancient [[https://tldp.org/HOWTO/Bash-Prompt-HOWTO/][Bash Prompt HOWTO]].

First, set a bunch of colours, some of which I don't use.

#+begin_src shell
RED="\[\033[0;31m\]"
# LIGHT_RED="\[\033[1;31m\]"
# YELLOW="\[\033[1;33m\]"
GREEN="\[\033[0;32m\]"
# LIGHT_GREEN="\[\033[1;32m\]"
# CYAN="\[\033[0;36m\]"
# LIGHT_CYAN="\[\033[1;36m\]"
BLUE="\[\033[0;34m\]"
# LIGHT_BLUE="\[\033[1;34m\]"
PURPLE="\[\033[0;35m\]"

# WHITE='\e[0;37m'
# LIGHT_GRAY="\[\033[0;37m\]"
# GRAY="\[\033[1;30m\]"
# BLACK="\[\033[0;30m\]"

NO_COLOUR="\[\033[0m\]"
#+end_src

I use a blue prompt on my home machine(s), green on my hosted shell server, and red elsewhere.

#+begin_src shell
case $HOSTNAME in
    marcus)
	PROMPT_COLOUR=$BLUE
	;;
    shell3)
	PROMPT_COLOUR=$GREEN
	;;
    ,*)
	PROMPT_COLOUR=$RED
esac
#+end_src

Root is purple.

#+begin_src shell
if [[ ${EUID} == 0 ]] ; then
    PROMPT_COLOUR=$PURPLE
fi
#+end_src

Now I can define the actual prompt.  Note that =\$= is # if root, $ otherwise; it needs to be escaped.

First a prompt I don't use, but it's good to keep as a reference.

#+begin_example
┌─[07:47 PM]─[wtd@marcus:~]
└─> $
#+end_example

#+begin_src shell :tangle no
export PS1="\342\224\214\342\224\200[\@]\342\224\200[\u@\h:\w]\n\342\224\224\342\224\200> \\$ "
#+end_example

Then the prompt I was using until I move this into Org.

#+begin_example
┌─[marcus]─[~/src/conforguration/dotfiles]
└─> $
#+end_example

#+begin_src shell :tangle no
PS1="\342\224\214\342\224\200[\h]\342\224\200[\w]\n\342\224\224\342\224\200> \\$ "
#+end_src

I simplified it a bit and discovered I can use Unicode characters instead of those ugly escape characters!

#+begin_example
┌─[marcus]─[~/src/conforguration/dotfiles]
└─$
#+end_example

#+begin_src shell
PS1="┌─[\h]─[\w]\n└─\\$ "
#+end_src

Set the prompt to be the colour I want.

#+begin_src shell
PS1="${PROMPT_COLOUR}${PS1}${NO_COLOUR}"
#+end_src

Glue the prompt to always go to the first column ([[https://jonisalonen.com/2012/your-bash-prompt-needs-this/][source]]).

#+begin_src shell
PS1="\[\033[G\]$PS1"
#+end_src

If I'm in a dumb terminal (when does that happen?) then use a very basic prompt.

#+begin_src shell
if [[ "$TERM" == "dumb" ]] ; then
    PS1="$ "
fi
#+end_src

Do I ever see a secondary prompt?  I'm not sure.

#+begin_src shell
PS2="${PROMPT_COLOUR}\342\224\224> ${NO_COLOUR}"
#+end_src

**** Key remapping

I used to need to remap some keys on my Lenovo X240, but whatever the problem was, I figured it out some other way, so this isn't needed.

#+begin_src shell :tangle no
if [ -f ~/.Xmodmap ]; then
    xmodmap ~/.Xmodmap
fi
#+end_src

**** Command aliases

Also use colours when grepping.

#+begin_src shell
alias grep='grep --color=auto'
#+end_src

Call up LibreOffice with just =o file=.

#+begin_src shell
alias o='libreoffice'
#+end_src

Open up [[https://alpine.x10host.com/][Alpine]] and go right to the inbox.

#+begin_src shell
alias pi='alpine -i'
#+end_src

Be polite.

#+begin_src shell
alias please='sudo'
#+end_src

In case =rm -i= is set system-wide.

#+begin_src shell
alias rm="rm"
#+end_src

Always preserve timestamps when using =scp=.

#+begin_src shell
alias scp="scp -p"
#+end_src

Get the weather with [[https://github.com/chubin/wttr.in][wttr.in]].

#+begin_src shell
alias ww="curl https://wttr.in/yyz"
#+end_src

Open any file in the default application with just =x file=.

#+begin_src shell
alias x='xdg-open'
#+end_src

**** ls

Count in proper kilobytes.

#+begin_src shell
export BLOCKSIZE=1024
#+end_src

Generally I'm on Linux machines, but if I'm on a FreeBSD box it has a different ls with different options, so I need to use a different alias to get colours.

On the Linux boxes:

+ classify: "append indicator (one of */=>@|) to entries" (to indicate directories, symlinks, etc.)
+ color: make the output in color (always)
+ quoting-style: show filenames as they are, so =File One.txt=, not ='File One.txt'= or =File\ One.txt=.  I'll put things in quotes if needed.

#+begin_src shell
if [[ $(uname) == "FreeBSD" ]] ; then
    alias ls='ls -F -G'
else # Presumably Linux
    alias ls='ls --classify --color --quoting-style=literal'
fi
#+end_src

Various short forms so I never have to actually type both letters of =ls=.

#+begin_src shell
alias l='ls'
alias la='l --all'
alias ll='l -l'
alias lla='l -l --all'
alias lsort='l -l -S --reverse'
#+end_src

**** w

Make =w= columns wider (very useful for hostnames).

#+begin_src shell
export PROCPS_FROMLEN=40
export PROCPS_USERLEN=12
#+end_src

**** More or less

I always want to use =less=, but I'm used to typing =more=.

#+begin_src shell
alias more='less'
alias mroe='more'
export PAGER=less
#+end_src

There is no =.lessrc=, so settings go in the =LESS= environment variable.  ([[https://www.topbug.net/blog/2016/09/27/make-gnu-less-more-powerful/][Source]].)

+ quit-if-one-screen:  if it all fits on screen, just show it and quit
+ ignore-case:  search are case-insensitive unless a capital letter is used
+ status-column:  show matches or where paging happened
+ LONG_PROMPT:  more verbose prompt
+ RAW-CONTROL-CHARS:  pass through raw ANSI colour escape sequences so colourizing can work
+ HILITE-UNREAD:  indicate first unread line after scrolling
+ tabs=4:  show a tab as four spaces
+ no-init:  don't clear screen after exiting; quit-if-one-screen needs this to be set
+ window=-4:  scroll by window size minus 4 lines, so there's overlap when scrolling

Pass through raw ANSI colour escape sequences.  In other words, make colourizing work.

#+begin_src shell
export LESS='--quit-if-one-screen --ignore-case --status-column --LONG-PROMPT --RAW-CONTROL-CHARS --HILITE-UNREAD --tabs=4 --no-init --window=-4'
#+end_src

=Lessfile= lets =less= open up tarred and gzipped files and so on and show what's inside.  If it's not installed, fall back to a script I wrote myself (see [[*Lessfilter][Lessfilter]] below).

#+begin_src shell
if command -v lessfile > /dev/null 2>&1; then
    eval "$(lessfile)"
    # This sets LESSOPEN and will pick up on ~/.lessfilter.
else
    # Fall back to do the best we can.
    export LESSOPEN="| ~/.lessfilter %s"
fi
#+end_src

If any syntax highlighters are available, use them.  =Pygmentize= does more, but =source-highlight= is still good.

#+begin_src shell
if command -v pygmentize > /dev/null 2>&1; then
    export LESSCOLOURIZER="pygmentize -f terminal"
elif command -v source-highlight > /dev/null 2>&1; then
    export LESSCOLOURIZER="source-highlight --failsafe --infer-lang -f esc --style-file=esc.style -i"
fi
#+end_src

**** Small functions and helpers

Pretty-print directory tree.  I never use this, but it could be useful as a reference.

#+begin_src shell
function tree() {
    find "${1:-.}" -type d -print | sed -e 's:[ ]*/:|____:g;s:____|: |:g'
}
#+end_src

Set an "alert" alias for long running commands.  Use like this: =sleep 10; alert=.

#+begin_src shell
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
#+end_src

Swap file $1 with $2.

#+begin_src shell
function swap() {
    local TMPFILE=tmp.$$
    mv "$1" $TMPFILE
    mv "$2" "$1"
    mv $TMPFILE "$2"
}
#+end_src

Handy way to watch a file grow

#+begin_src shell
function monitor() {
    while true ; do
	clear
	tail "$1"
	sleep 10
    done
}
#+end_src

"| order" is very handy for counting duplicated lines in a file or listing.

#+begin_src shell
function order() {
    sort | uniq -c | sort -rn
}
#+end_src

Wipe all metadata from one or more images.

#+begin_src shell
function exifwipe() {
    for FILE in "$@"; do
	exiftool -all= "$FILE"
    done
}
#+end_src

My SanDisk Clip Sport can't play 24-bit FLAC files, so I need to run =sansify *flac*= to make them 16-bit.

#+begin_src shell
function sansify() {
    for FILE in "$@"; do
	sox "${FILE}" --bits 16 --rate 44.1k "16-${FILE}"
	rm "$FILE"
    done
}
#+end_src

Sum a list of numbers.

#+begin_src shell
function colsum {
    paste -s -d+ | bc --
}
#+end_src

#+begin_example
$ (echo 1; echo 3; echo 5) | colsum
9
#+end_example

**** Completions

Git.  Can be found as part of Git source.

#+begin_src shell
source ~/.git-completion.bash
#+end_src

Bash.  Requires bash-completion package.

#+begin_src shell
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    source /etc/bash_completion
fi
#+end_src

**** PATH

Here I build up the PATH bit by bit.  Put =/usr/local/bin= first (ahead of whatever is inherited from the system setting).

#+begin_src shell
PATH=/usr/local/bin:$PATH
#+end_src

Make sure the rootly paths are there.

#+begin_src shell
PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin
#+end_src

Emacs is run from source in =/usr/local/src/emacs=.

#+begin_src shell
PATH=/usr/local/src/emacs/src:$PATH
alias emacsclient="/usr/local/src/emacs/lib-src/emacsclient"
alias e="emacsclient --no-wait"
#+end_src

I run R from source in =/usr/local/src/R=.

#+begin_src shell
if [ -f /usr/local/src/R/R ] ; then
    PATH=/usr/local/src/R:$PATH
fi
#+end_src

Zotero needs to be [[https://www.zotero.org/support/installation][installed]] by hand.

#+begin_src shell
alias zotero="/usr/local/src/zotero/Zotero_linux-x86_64/zotero"
#+end_src

I put ircii's irc in ~/.irc/.

#+begin_src shell
PATH=$PATH:~/.irc/
#+end_src

Ruby: I use [[https://github.com/rbenv/rbenv][rbenv]] to handle Ruby.  If rbenv isn't there, it will default to the system Ruby.

#+begin_src shell
if [ -d ~/.rbenv/ ] ; then
    PATH=$HOME/.rbenv/bin:$PATH
    eval "$(rbenv init -)"
fi
#+end_src

Go (=go help gopath=).

#+begin_src shell
export GOPATH=~/.gopath
PATH=$PATH:$GOPATH/bin/
#+end_src

Pip (from Python).

#+begin_src shell
PATH=$PATH:~/.local/bin/
#+end_src

Rust.

#+begin_src shell
PATH=$PATH:~/.cargo/bin/
#+end_src

My own scripts, and finally, the current directory.

#+begin_src shell
PATH=$PATH:~/bin/:.
#+end_src

**** Local settings

There are some settings that I want just on a particular machine, and this makes that possible.  If the machine is named =dartagnan=, put machine-specific environment variables and settings in =~/.bash.dartagnan.rc=.

#+begin_src shell
if [ -f ~/.bash."$HOSTNAME".rc ] ; then
    . ~/.bash.$HOSTNAME.rc
fi
#+end_src

*** Dircolors (=dircolors.ansi-dark=) (imported)

https://github.com/seebi/dircolors-solarized/blob/master/dircolors.ansi-dark

"Solarized Color Theme for GNU ls (as setup by GNU dircolors)"

https://github.com/seebi/dircolors-solarized

Raw source:  [[https://raw.githubusercontent.com/seebi/dircolors-solarized/master/dircolors.ansi-dark][dircolors.ansi-dark]].

Imported copy: [[file:imported/dircolors.ansi-dark][imported/dircolors.ansi-dark]].

*** Logout (=.bash_logout=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/bash_logout
:END:

"When an interactive login shell exits, or a non-interactive login shell executes the exit builtin command, bash reads and executes commands
from the file =~/.bash_logout=, if it exists," says the =bash= man page.

The only command I have here is one I pasted in from I don't know where.  It clears the console when I log out, for privacy.  It's been years since I logged in through a console to run X, but who knows.

=SHLVL= is "incremented by one each time an instance of =bash= is started," so this runs if the shell being exited is not a sub-shell of another.

#+begin_src shell
if [ "$SHLVL" = 1 ]; then
    [ -x /usr/bin/clear_console ] && /usr/bin/clear_console -q
fi
#+end_src


** Git

*** Completion (imported)

https://github.com/git/git/blob/master/contrib/completion/git-completion.bash

*** Config (=.gitconfig=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/gitconfig
:END:

TODO:  Expand on what all this means.  Find a better way to handle the editor for cases where I'm on a remote server without Emacs running.

#+begin_src gitconfig
[include]
	path = ~/.gitconfig.local
[color]
	ui = auto
	pager = true
[column]
	ui = auto
[core]
	editor = emacsclient
[user]
	name = William Denton
	email = wtd@pobox.com
[push]
	default = current
[alias]
	hist = log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all
#+end_src

** LaTeX

*** ChkTeX (=.chktexrc=) (imported)

[[https://www.nongnu.org/chktex/][ChkTex]] is linter for LaTeX.  I think it complained about not having a configuration file when I first ran it, so I copied the default.

TODO:  did i tweak anything?  investigate.  for now, since it's so long and complicated, just leave it here.

Raw source: [[http://git.savannah.nongnu.org/cgit/chktex.git/plain/chktex/chktexrc][chktexrc]].

Imported copy: [[file:imported/chktexrc][imported/chktexrc]].

** Less

*** Lessfilter (=.lessfilter=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/lessfilter :shebang "#!/bin/bash"
:END:

See [[*More or less][More or less]] above for where this fits in to the =less= configuration.  This short script enables pre-processing of files before =less= displays them, which allows syntax highlighting and even extracting text from PDFs.  It's pretty amazing when you can run =less foo.pdf= and see what's in the PDF as plain text.

There are some requirements for this to work:

+ [[https://pygments.org/][Pygments]] (see what it can handle with =pygmentize -L lexers=)
+ [[https://www.gnu.org/software/src-highlite/][GNU source-highlight]]
+ [[https://poppler.freedesktop.org/][Poppler]] (for =pdftotext=)

To install them on Ubuntu, run this:

#+begin_src shell :tangle no
sudo apt install python-pygments source-highlight poppler-utils
#+end_src

=LESSCOLOURIZER= is defined in =.bashrc=.  It will be either =pygmentize= (preferred) or =source-highlight= (fallback, if it's installed).  Whichever is available, use it for everything except PDFs, where we use =pdftotext=.

This case statement defines which program handles which file types.  Pygmentize can handle many more than are here; this is just the ones I want.  My =.bashrc= doesn't get processed correctly, maybe because of escape sequences, so I left it out.

#+begin_src shell
if [ -v LESSCOLOURIZER ]; then
    case "$1" in
	.bash_|*.bat|*.bib|*.c|Changelog|*.diff|Gemfile|*.gemspec|*.h|*.html|*.ini|*.js|*.json|*.jsonld|\
	    Makefile|*.md|*.patch|*.php|*.pl|*.pm|*.py|Rakefile|*.rake|*.rb|*.R|*.Rprofile|*.rss|*.sh|*.sql|*.xsl|*.tex|*.toc|*.yaml|*.yml)
	    $LESSCOLOURIZER "$1" ;;
	,*.pdf)
	    if command -v pdftotext > /dev/null 2>&1 ; then pdftotext -layout "$1" -
	    else echo "No pdftotext available; try installing poppler-utils"; fi ;;
	,*)
	    # Pass through to lessfile
	    exit 1
    esac;
fi
#+end_src

Finally, if =LESSCOLOURIZER= is not set, hand off to =lessfile=.

#+begin_src shell
exit 1
#+end_src

** Nano

*** Config (=.nanorc=)

:PROPERTIES:
:header-args: :tangle dotfiles/mine/nanorc
:END:

#+begin_src nano
set fill -8
set nonewlines
set nowrap
set softwrap
set suspend
#+end_src

** R

[[https://www.r-project.org/][R]]'s web site says it "is a free software environment for statistical computing and graphics," which doesn't adequately describe how awesome it is.  I mainly use R through Emacs, but there are some settings that apply just to how R works that I want defined however R is run.

*** Rprofile (=.Rprofile=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/Rprofile
:END:

See also [[https://stackoverflow.com/q/1189759/854346][Expert R users, what's in your .Rprofile?]] from Stack Overflow.

First, hard code a nearby (to me) repo for [[https://cran.r-project.org/][CRAN]] packages.

TODO:  The mirror is also used in [[file:~/src/conforguration/conforguration.org::*Setup: R][Setup: R]] ... maybe I could put it into a bash environment variable in one place and get all the mentions from there?

#+begin_src R
r <- getOption("repos")
r["CRAN"] <- c("https://utstat.toronto.edu/cran/")
options(repos = r)
rm(r)
#+end_src

I don't need to keep histories of everything.  I used to log everything to history files but never looked at them and discovered after a while that the directory was filled with 0-byte files.  I'll leave in the command to do that in case it's useful again one day.

#+begin_src R
Sys.setenv(R_HISTSIZE = '0')
## sink(file = paste('~/R/history/r-log-', strftime(Sys.time(), '%F %H:%M:%OS9'), sep = ''), split=T)
#+end_src

Should R automatically convert strings to factor variables in a data.frame?  No!  This is the default in 4.0 and up, but I'll leave it in for now.

#+begin_src R
options(stringsAsFactors = FALSE)
#+end_src

Override =q()= to not save by default.  Same as saying =q("no")=.

#+begin_src R
q <- function (save="no", ...) {
    quit(save=save, ...)
}
#+end_src

No menu popups:  use the console.

#+begin_src R
options(menu.graphics = FALSE)
#+end_src

Tab completion on =library()= and =require()=.

#+begin_src R
utils::rc.settings(ipck = TRUE)
#+end_src

Set the prompt?  I used to use a fancy "ℝ", but now just the default simple ">".  But I'll leave this here in case I want to go back.

#+begin_src R
## options(prompt="ℝ> ")
#+end_src

** Ruby

*** Gems (=.gemrc=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/gemrc
:END:

#+begin_src yaml
---
:verbose: true
:benchmark: false
:bulk_threshold: 1000
:update_sources: true
:backtrace: false
gem: --no-document
#+end_src

*** Pry (=.pryrc=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/pryrc
:END:

[[https://pry.github.io/][Pry]] "is a powerful alternative to the standard IRB shell for Ruby. It features syntax highlighting, a flexible plugin architecture, runtime invocation and source and documentation browsing."  See also the [[https://github.com/pry/pry/wiki/Pry-rc][pryrc documentation]].

The only setting here is to hook in [[https://github.com/awesome-print/awesome_print][awesome_print]] so that by default everything is nicely pretty-printed.

#+begin_src ruby
require "awesome_print"
AwesomePrint.pry!
#+end_src

*** Rubocop (=.rubocop.yml=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/rubocop.yml
:END:

[[https://github.com/rubocop/rubocop/][Rubocop]] "is a Ruby static code analyzer (a.k.a. linter) and code formatter."

I prefer using "double quotes" when quoting.  Everything else I leave as is.  When needed I can turn off a warning in the code itself.

#+begin_src yaml
Style/StringLiterals:
  EnforcedStyle: double_quotes
  SupportedStyles:
    - single_quotes
    - double_quotes

AllCops:
  NewCops: enable
#+end_src


** Signature

*** Personal (=.signature=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/signature
:END:

This is my personal sig.

#+begin_src text
--
William Denton :: Toronto, Canada   ---   Listening to Art: https://listeningtoart.org/
https://www.miskatonic.org/         ---   GHG.EARTH: https://ghg.earth/
Caveat lector.                      ---   STAPLR: https://staplr.org/
#+end_src

*** Work (=.signature.work=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/signature.work
:END:

This is the sig I use at work.

#+begin_src text
William Denton  <wdenton@yorku.ca>
Associate Librarian: Scholarly Analytics / Mathematics & Statistics
York University (Toronto) https://www.library.yorku.ca/

GHG.EARTH: https://ghg.earth/
STAPLR: https://staplr.org/

"The library is the mathematician's laboratory." --- Paul Halmos
#+end_src


** Tmux

*** Config (=.tmux.conf=)

:PROPERTIES:
:header-args: :tangle dotfiles/mine/tmux.conf
:END:

Start window numbering at 1.

#+begin_src tmux
set -g base-index 1
#+end_src

Status bar formatting.

#+begin_src tmux
set -g status-left-length 20
set -g status-left ""
set -g status-right "[Session: #S]"
set -g status-justify centre
#+end_src

Colours, taken from [[https://github.com/seebi/tmux-colors-solarized][tmux-colors-solarized]].  First, set the terminal type.

#+begin_src tmux
set -g default-terminal "screen-256color"
#+end_src

Default statusbar colors.

#+begin_src tmux
set-option -g status-bg black
set-option -g status-fg yellow
#+end_src

Pane number display.

#+begin_src tmux
set-option -g display-panes-active-colour blue
set-option -g display-panes-colour brightred
#+end_src

Clock.

#+begin_src tmux
set-window-option -g clock-mode-colour green
#+end_src
Bell.

#+begin_src tmux
set-window-option -g window-status-bell-style fg=black,bg=red
#+end_src

** X

*** Xmodmap (=.xmodmaprc=)
:PROPERTIES:
:header-args: :tangle dotfiles/mine/xmodmaprc
:END:

Do I actually need this?  I'm not loading it in.  Is it being caught automatically?

TODO:  Try disabling it and see what happens.

#+begin_src xmodmap
keysym Home = Insert
keysym End = Insert
#+end_src
* Emacs

** Requirements

You can't build anything from source without making sure all the necessary utilities and libraries are there first.  Once done, this will never need to be run again.

#+begin_src shell :tangle conforguration_scripts/emacs-install-requirements.sh :shebang "#!/bin/bash"
sudo apt-get build-dep emacs
sudo apt-get install libjansson-dev valgrind fonts-firacode
## On Linux Mint, at least, these are not installed when the above is done.  Curious.
## On other systems, it can't hurt.
sudo apt-get install texinfo libxpm-dev libjpeg-dev libgif-dev libtiff-dev libtinfo-dev
#+end_src

** Install for personal use

First get the source for Emacs and compile it.

#+begin_src shell :tangle conforguration_scripts/emacs-install-personal.sh :shebang "#!/bin/bash"
cd /usr/local/src/
git clone https://git.savannah.gnu.org/git/emacs.git
cd emacs
./autogen.sh
./configure
make
#+end_src

Then do the same for Org.

#+begin_src shell :tangle conforguration_scripts/emacs-install-personal.sh :shebang "#!/bin/bash"
cd /usr/local/src/
git clone https://code.orgmode.org/bzg/org-mode.git
cd org-mode
make
#+end_src

Finally, get my Emacs configuration (which is not here in Conforguration).  It will be cloned into =~/.emacs.d/=.  (Requires a GitHub account when done this way.)

#+begin_src shell :tangle conforguration_scripts/emacs-install-personal.sh :shebang "#!/bin/bash"
cd
git clone git@github.com:wdenton/.emacs.d.git
# Or
# git clone https://github.com/wdenton/.emacs.d.git
# if you don't want to use a GitHub account.
echo "Now run emacs, and say no when asked about a location for abbrev_defs."
#+end_src

Running ~emacs~ the first time will download and install all the packages needed, but some setting about =abbrevs= is misordered so it will ask a question it doesn't need to ask.  Saying no makes everything work.

It's probably best to quit Emacs and restart after this, but you don't actually need to.

** Update

This is a simple script that pulls down the updated source for Emacs and Org and compiles them.  If something goes wrong with the Emacs compile you might need to do =make clean= or =make distclean= or =make extraclean= and then try again.

#+begin_src shell :tangle conforguration_scripts/emacs-update.sh :shebang "#!/bin/bash"
cd /usr/local/src/emacs/
git pull
./configure && make
cd ../org-mode/
make update
#+end_src

* R

For running a personal version of R, ~PATH~ needs to include ~/usr/local/src/R~, but my bashrc will set that up if it's there.

Change the version number as needed, then tangle and run the install script again.

#+NAME: R_VERSION
| 4.0.4 |

** Requirements

The first line of requirements may be needed for R 3.3.  The ~topicmodels~ package requires the GNU Scientific Library.  Once done, this doesn't need to be run again.  Sync and run the script on machines as necessary.

#+begin_src shell :tangle conforguration_scripts/r-install-requirements.sh :shebang "#!/bin/bash"
sudo apt-get install libbz2-dev liblzma-dev libxml2-dev libpcre2-dev libpcre3-dev fonts-inconsolata
sudo apt-get install xorg-dev gfortran libreadline-dev libcurl4-openssl-dev libssl-dev libgsl-dev libcurl4-openssl-dev
sudo apt-get curl build-dep r-base
mkdir -p ~/R/history/
mkdir -p /usr/local/src/R
#+end_src

** Noweb setup

Whether R is being installed system-wide or just for personal use, this code will be run.

#+begin_src :shell :noweb-ref r_source_code_present_and_compiled
cd $(dirname "$0")
SCRIPTS_DIR=$(pwd)
MIRROR="https://utstat.toronto.edu/cran/"
cd /usr/local/src/R
#+end_src

If the source has been untarred already, wipe that directory because we want to start fresh.

#+begin_src :shell :noweb-ref r_source_code_present_and_compiled
if [ -d "/usr/local/src/R/R-${R_VERSION}" ]; then
  echo "Removing old source directory ..."
  rm -r R-${R_VERSION}
fi
#+end_src

If the source tarball is there, use it, otherwise download.  The =R_MAJOR= variable is there because we need to know the major version number, so we can get to e.g. base/R-4 to download 4.0.4.

#+begin_src :shell :noweb-ref r_source_code_present_and_compiled
if ! [ -f "R-${R_VERSION}.tar.gz" ]; then
  echo "Downloading R-${R_VERSION} tarball ..."
  R_MAJOR=${R_VERSION:0:1}
  curl -O $MIRROR/src/base/R-${R_MAJOR}/R-${R_VERSION}.tar.gz
else
  echo "Using existing R-${R_VERSION} tarball ..."
fi
#+end_src

Now uncompress, configure and compile.  This could take a while.

#+begin_src :shell :noweb-ref r_source_code_present_and_compiled
echo "Uncompressing ..."
tar xzvf R-$R_VERSION.tar.gz

echo "Compiling ..."
cd R-$R_VERSION
./configure --enable-R-shlib
make && make check
#+end_src

** Install for personal use

Here we set up symlinks to point to the ~R~ and ~Rscript~ executables, then source ~.bashrc~ to refresh ~$PATH~ to notice them and put that ~Rscript~ first, which makes the package installation work.

First, get R downloaded and compiled.

#+begin_src shell :tangle conforguration_scripts/r-install-personal.sh :shebang "#!/bin/bash" :noweb yes :var R_VERSION=R_VERSION
<<r_source_code_present_and_compiled>>
#+end_src

Next, set up the aliases for it in =/usr/local/src/R/=.  To be sure they work, reload bash to pick up on the PATH.

#+begin_src shell :tangle conforguration_scripts/r-install-personal.sh :shebang "#!/bin/bash" :noweb yes :var R_VERSION=R_VERSION
cd /usr/local/src/R/
rm -f R Rscript
ln -s R-${R_VERSION}/bin/R R
ln -s R-${R_VERSION}/bin/Rscript Rscript

source ~/.bashrc
#+end_src

Finally, install the packages.

#+begin_src shell :tangle conforguration_scripts/r-install-personal.sh :shebang "#!/bin/bash" :noweb yes :var R_VERSION=R_VERSION
cd $SCRIPTS_DIR
./r-install-packages.sh
#+end_src

** Install system-wide

R packages need to be installed in a full root login.  There's probably a way to do this with ~sudo -i~, but I can't figure it out, so I do it this convoluted way.  It works, but if there's a better way, please let me know.  Here we become root, then get back to the directory where the package installation script is so we can run it.

#+begin_src shell :tangle conforguration_scripts/r-install-system.sh :shebang "#!/bin/bash" :noweb yes :var R_VERSION=R_VERSION
<<r_source_code_present_and_compiled>>
sudo make install

sudo su - -c "cd $SCRIPTS_DIR; ./r-install-packages.sh"
#+end_src

** Packages

There are quite a few R packages I want installed by default, including of course the [[https://www.tidyverse.org/][Tidyverse]], which I greatly admire.  The packages are all in this next table.  Add to (and resort) as needed.

#+NAME: r_packages
| RCurl         |
| arules        |
| arulesViz     |
| cluster       |
| devtools      |
| docopt        |
| flexdashboard |
| fpc           |
| fs            |
| geonames      |
| geosphere     |
| ggrepel       |
| ggridges      |
| ggvis         |
| hms           |
| igraph        |
| knitr         |
| lintr         |
| lubridate     |
| mapproj       |
| maps          |
| maptools      |
| osmdata       |
| readxl        |
| remotes       |
| rgeos         |
| roxygen2      |
| seriation     |
| sf            |
| shiny         |
| skimr         |
| testthat      |
| tidyverse     |
| tm            |
| topicmodels   |
| usethis       |
| xlsx          |

Now we need to transform that list into some shell commands.  First, we're going to turn the list into a shell variable, =package_list=, with a neat [[https://stackoverflow.com/a/9429887/854346][array join tip]] I saw on Stack Overflow.  This code block sets up the variable in another code block.  (Make sure the name =packages-list-variable= is set or the noweb tangling won't work.)

#+begin_src shell :results output :var pkgs=r_packages :results code
echo -n 'package_list="'
IFS=" " ; echo -n "${pkgs[*]}"
echo -n '"'
#+end_src

#+NAME: packages-list-variable
#+RESULTS:
#+begin_src shell
package_list="RCurl arules arulesViz cluster devtools docopt flexdashboard fpc fs geonames geosphere ggrepel ggridges ggvis hms igraph knitr lintr lubridate mapproj maps maptools osmdata readxl remotes rgeos roxygen2 seriation sf shiny skimr testthat tidyverse tm topicmodels usethis xlsx"
#+end_src

And the above code block is included in the one below with noweb.

#+begin_src shell :tangle conforguration_scripts/r-install-packages.sh :shebang "#!/bin/bash" :noweb yes
<<packages-list-variable>>
for pkg in $package_list
do
    Rscript --vanilla -e "install.packages('$pkg', repos=c('https://utstat.toronto.edu/cran/'))"
done
Rscript --vanilla -e "devtools::install_github('yorkulibraries/yulr')"
#+end_src

When tangled, the script will have the full =package_list= definition with all the packages, and it loops through them all, installing one by one (with dependencies, where required).  There are a lot of packages, so this will take a while.

* Ruby

#+NAME: RUBY_VERSION
| 3.0.0 |

** Requirements

Make sure some necessities are in place before trying to build from source.

#+begin_src shell :tangle conforguration_scripts/ruby-install-requirements.sh :shebang "#!/bin/bash"
sudo apt-get build-dep ruby
sudo apt-get install libreadline-dev libsqlite3-dev
#+end_src

** Install (or upgrade) rbenv

This script installs [[https://github.com/rbenv/rbenv][rbenv]] if it isn't already in place; if it is, it updates it.  It checks to see if =~/.rbenv/= exists; if it does, =rbenv= is installed, so it just tries to update it; if not, it installs it.

#+begin_src shell :tangle conforguration_scripts/ruby-rbenv.sh :shebang "#!/bin/bash"
if [[ -d ~/.rbenv ]]; then
    echo "Upgrade if possible"
    cd ~/.rbenv/
    git pull
    cd plugins/ruby-build
    git pull
else
    echo "Installing"
    git clone https://github.com/rbenv/rbenv.git ~/.rbenv
    git clone https://github.com/rbenv/ruby-build.git ~/.rbenv/plugins/ruby-build
    source ~/.bashrc
fi
#+end_src

This can be called with noweb by source blocks below to install =rbenv= on a remote machine.

#+NAME: ruby-rbenv-remotely
#+begin_src shell
ssh ${hostname} "conforguration_scripts/ruby-rbenv.sh"
#+end_src

** Install with rbenv for personal use

#+begin_src shell :tangle conforguration_scripts/ruby-install-personal.sh :shebang "#!/bin/bash" :var RUBY_VERSION=RUBY_VERSION
rbenv install --verbose $RUBY_VERSION
rbenv global $RUBY_VERSION
~/conforguration_scripts/ruby-install-gems.sh
echo "Now run bundle install where needed."
#+end_src

#+NAME: ruby-install-personal-remotely
#+begin_src shell
ssh ${hostname} "conforguration_scripts/ruby-install-personal.sh"
#+end_src

** Install system-wide

#+begin_src shell :tangle conforguration_scripts/ruby-install-system.sh :shebang "#!/bin/bash" :var RUBY_VERSION=RUBY_VERSION
mkdir -p /usr/local/src/ruby
cd /usr/local/src/ruby

curl -LO https://cache.ruby-lang.org/pub/ruby/2.7/ruby-${RUBY_VERSION}.tar.gz
tar xzvf ruby-${RUBY_VERSION}.tar.gz
cd ruby-${RUBY_VERSION}

./configure
make

sudo make install
sudo ~/conforguration_scripts/ruby-install-gems.sh

echo "Now run bundle install where needed."
#+end_src

#+NAME: ruby-install-system-remotely
#+begin_src shell
ssh ${hostname} "conforguration_scripts/ruby-install-system.sh"
#+end_src

** Install gems

This works like the R packages do.  First, a list of gems I want installed by default.

#+NAME: ruby_gems
| awesome_print |
| bundler       |
| docopt        |
| http          |
| marc          |
| nokogiri      |
| pry           |
| pry-doc       |
| rubocop       |
| rubyul        |
| sqlite3       |

Now transform that list into some shell commands into a shell variable, GEM_LIST.  This code block generates the next one.

#+begin_src shell :results output :var gems=ruby_gems :results code
echo -n 'GEM_LIST="'
IFS=" " ; echo -n "${gems[*]}"
echo -n '"'
#+end_src

#+NAME: gem-list-variable
#+RESULTS:
#+begin_src shell
GEM_LIST="awesome_print bundler docopt http marc nokogiri pry pry-doc rubocop rubyul sqlite3"
#+end_src

And the above code block is included in the one below with noweb.

#+begin_src shell :tangle conforguration_scripts/ruby-install-gems.sh :shebang "#!/bin/bash" :noweb yes
<<gem-list-variable>>
for gem in $GEM_LIST
do
    gem install $gem
done
#+end_src

* Machines

** Noweb setup

This one call to =rsync= will push the Conforguration scripts to a remote host.  The =${hostname}= variable is defined in the PROPERTIES for each host's subheading below (except localhost, because here we can copy files directly), and the script is run with noweb.

#+NAME: copy-conforguration-scripts-remotely
#+begin_src shell
rsync --archive --compress --delete --times conforguration_scripts/ ${hostname}:conforguration_scripts/
#+end_src

** localhost

*** Dot files

#+begin_src shell :results output
dotfiles/copy-dotfiles.shd
dotfiles/link-dotfiles.sh
#+end_src

#+RESULTS:
#+begin_example
mine
   abcde.conf
   bash_logout
   bash_profile
   bashrc
   gemrc
   gitconfig
   lessfilter
   nanorc
   pryrc
   Rprofile
   rubocop.yml
   signature
   signature.work
   tmux.conf
   xmodmaprc
imported
   chktexrc
   dircolors.ansi-dark
   git-completion.bash
#+end_example

** music
:PROPERTIES:
:header-args: :var hostname="music"
:END:

*** Dot files

#+begin_src shell :results silent :noweb yes
<<install-dotfiles-remotely>>
#+end_src

*** Push scripts

#+begin_src shell :results silent :noweb yes
<<copy-conforguration-scripts-remotely>>
#+end_src

*** Install Emacs remotely one way

#+begin_src shell :dir /scp:wtd@music:conforguration_scripts/ :results silent
# ./emacs-install-requirements.sh
./emacs-install-personal.sh
#+end_src

*** Install Ruby remotely the other way

#+begin_src shell :results silent :noweb yes
<<ruby-rbenv-remotely>>
#+end_src

#+begin_src shell :results silent :noweb yes
<<ruby-install-personal-remotely>>
#+end_src


*** Testing

#+name: one
#+begin_src shell
echo "one"
sleep 10
#+end_src

#+RESULTS:
: one

#+name: two
#+begin_src shell
echo "two three"
sleep 10
#+end_src

#+RESULTS: two
: two three

# :dir /music:

#+begin_src shell  :results output :noweb yes
<<one>>
<<two>>
#+end_src

#+RESULTS:
: one
: two three

** pihole
:PROPERTIES:
:header-args: :var hostname="pihole"
:END:

*** Dot files

#+begin_src shell :results silent :noweb yes
<<install-dotfiles-remotely>>
#+end_src

** studio
:PROPERTIES:
:header-args: :var hostname="music"
:END:

*** Dot files

#+begin_src shell :results silent :noweb yes
<<install-dotfiles-remotely>>
#+end_src

** tor
:PROPERTIES:
:header-args: :var hostname="tor"
:END:

*** Dot files

#+begin_src shell :results silent :noweb yes
<<install-dotfiles-remotely>>
#+end_src

** pair
:PROPERTIES:
:header-args: :var hostname="pair"
:END:

*** Dot files

#+begin_src shell :results silent :noweb yes
<<install-dotfiles-remotely>>
#+end_src

** shell3
:PROPERTIES:
:header-args: :var hostname="shell3"
:END:

*** Dot files

#+begin_src shell :results silent :noweb yes
<<install-dotfiles-remotely>>
#+end_src

*** Push scripts

#+begin_src shell :results silent :noweb yes
<<copy-conforguration-scripts-remotely>>
#+end_src

** wdenton2
:PROPERTIES:
:header-args: :var hostname="wdenton2"
:END:

*** Dot files

#+begin_src shell :results silent :noweb yes
<<install-dotfiles-remotely>>
#+end_src

*** Push scripts

#+begin_src shell :results silent :noweb yes
<<copy-conforguration-scripts-remotely>>
#+end_src

** orez
:PROPERTIES:
:header-args: :var hostname="orez"
:END:

*** Dot files

#+begin_src shell :results silent :noweb yes
<<install-dotfiles-remotely>>
#+end_src

*** Push scripts

#+begin_src shell :results silent :noweb yes
<<copy-conforguration-scripts-remotely>>
#+end_src
